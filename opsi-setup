#!/usr/bin/python
# = = = = = = = = = = = = = = = = = = = = = = =
# =       Copyright (C) 2011 uib GmbH         =
# =           http://www.uib.de               =
# =          All rights reserved.             =
# = = = = = = = = = = = = = = = = = = = = = = =


from OPSI.Logger import *
from OPSI.Types import *
from OPSI.Object import *
from OPSI.System import *
from OPSI.Util.File import *
from OPSI.Util.File.Opsi import *
from OPSI.Util import *
from OPSI.UI import *
from OPSI.Backend.MySQL import *
from OPSI.Backend.LDAP import *
from OPSI.Backend.File import *
from OPSI.Backend.JSONRPC import *
from OPSI.Backend.Backend import ExtendedConfigDataBackend

import os, sys, socket, re, shutil, getopt, pwd, grp, stat, codecs, time, MySQLdb, ldap
from OpenSSL import crypto, SSL, rand

if (sys.version_info >= (2,6)):
	import json
else:
	import simplejson as json

logger = Logger()

logger.setConsoleLevel(LOG_NOTICE)
logger.setConsoleColor(True)

LOG_FILE         = u'/tmp/opsi-setup.log'
SMB_CONF         = u'/etc/samba/smb.conf'
SMB_INIT         = u'/etc/init.d/samba'
DHCPD_CONF       = Posix.locateDHCPDConfig(u'/etc/dhcp3/dhcpd.conf')
DHCPD_INIT       = Posix.locateDHCPDInit(u'/etc/init.d/dhcp3-server')
SUDOERS          = u'/etc/sudoers'
OPSICONFD_USER   = u'opsiconfd'
ADMIN_GROUP      = u'opsiadmin'
CLIENT_USER      = u'pcpatch'
FILE_ADMIN_GROUP = u'pcpatch'

OPSI_CONF = u'/etc/opsi/opsi.conf'
OPSI_GLOBAL_CONF = u'/etc/opsi/global.conf'

try:
	FILE_ADMIN_GROUP = OpsiConfFile(OPSI_CONF).getOpsiFileAdminGroup()
except:
	FILE_ADMIN_GROUP = u'pcpatch'
 
if os.path.exists(u'/etc/init.d/smbd'):
	SMB_INIT = u'/etc/init.d/smbd'
if os.path.exists(u'/etc/init.d/smb'):
	SMB_INIT = u'/etc/init.d/smb'

sysConfig = {}

def getSysConfig():
	global sysConfig
	if sysConfig:
		return sysConfig
	
	sysConfig['distributor'] = u'unknown'
	sysConfig['distribution'] = u'unknown'
	try:
		f = os.popen('lsb_release -i 2>/dev/null')
		sysConfig['distributor'] = f.read().split(':')[1].strip()
		f.close()
		f = os.popen('lsb_release -d 2>/dev/null')
		sysConfig['distribution'] = f.read().split(':')[1].strip()
		f.close()
	except Exception, e:
		logger.warning(u"Failed to get distributor/distribution: %s" % e)
		
	logger.notice(u"Getting current system config")
	if ipAddress:
		sysConfig['ipAddress'] = ipAddress
	try:
		sysConfig['fqdn'] = forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF))
	except:
		raise Exception(u"Failed to get fully qualified domain name, got '%s'" % getfqdn(conf=OPSI_GLOBAL_CONF))
	
	sysConfig['hostname'] = sysConfig['fqdn'].split(u'.')[0]
	sysConfig['domain'] = u'.'.join(sysConfig['fqdn'].split(u'.')[1:])
	if not sysConfig.has_key('ipAddress'):
		sysConfig['ipAddress'] = socket.gethostbyname(sysConfig['fqdn'])
		if sysConfig['ipAddress'].split(u'.')[0] in ('127', '169'):
			sysConfig['ipAddress'] = None
	sysConfig['hardwareAddress'] = None
	
	for device in getEthernetDevices():
		devconf = getNetworkDeviceConfig(device)
		if devconf['ipAddress'] and devconf['ipAddress'].split(u'.')[0] not in ('127', '169'):
			if not sysConfig['ipAddress']:
				sysConfig['ipAddress'] = devconf['ipAddress']
			if (sysConfig['ipAddress'] == devconf['ipAddress']):
				sysConfig['netmask']         = devconf['netmask']
				sysConfig['hardwareAddress'] = devconf['hardwareAddress']
				break
	
	if not sysConfig['ipAddress']:
		raise Exception(u"Failed to get a valid ip address for fqdn '%s'" % sysConfig['fqdn'])
	
	if not sysConfig.get('netmask'):
		sysConfig['netmask'] = u'255.255.255.0'
	
	sysConfig['broadcast'] = u''
	sysConfig['subnet']    = u''
	for i in range(4):
		if sysConfig['broadcast']: sysConfig['broadcast'] += u'.'
		if sysConfig['subnet']:    sysConfig['subnet']    += u'.'
		sysConfig['subnet']    += u'%d' % ( int(sysConfig['ipAddress'].split(u'.')[i]) & int(sysConfig['netmask'].split(u'.')[i]) )
		sysConfig['broadcast'] += u'%d' % ( int(sysConfig['ipAddress'].split(u'.')[i]) | int(sysConfig['netmask'].split(u'.')[i]) ^ 255 )
	
	sysConfig['winDomain'] = u''
	if os.path.exists(SMB_CONF):
		f = codecs.open(SMB_CONF, 'r', 'utf-8')
		for line in f.readlines():
			match = re.search('^\s*workgroup\s*=\s*(\S+)\s*$', line)
			if match:
				sysConfig['winDomain'] = match.group(1).upper()
				break
		f.close()
	
	logger.notice(u"System information:")
	logger.notice(u"   distributor  : %s" % sysConfig['distributor'])
	logger.notice(u"   distribution : %s" % sysConfig['distribution'])
	logger.notice(u"   ip address   : %s" % sysConfig['ipAddress'])
	logger.notice(u"   netmask      : %s" % sysConfig['netmask'])
	logger.notice(u"   subnet       : %s" % sysConfig['subnet'])
	logger.notice(u"   broadcast    : %s" % sysConfig['broadcast'])
	logger.notice(u"   fqdn         : %s" % sysConfig['fqdn'])
	logger.notice(u"   hostname     : %s" % sysConfig['hostname'])
	logger.notice(u"   domain       : %s" % sysConfig['domain'])
	logger.notice(u"   win domain   : %s" % sysConfig['winDomain'])
	
	return sysConfig


def configureSamba():
	logger.notice(u"Configuring samba")
	
	f = codecs.open(SMB_CONF, 'r', 'utf-8')
	lines = f.readlines()
	f.close()
	newlines = []
	optPcbinShareFound = False
	depotShareFound = False
	configShareFound = False
	workbenchShareFound = False
	confChanged = False
	
	for i in range(len(lines)):
		if (lines[i].lower().strip() == '; load opsi shares') and ((i+1) < len(lines)) and (lines[i+1].lower().strip() == 'include = /etc/samba/share.conf'):
			i += 1
			confChanged = True
			continue
		if   (lines[i].lower().strip() == '[opt_pcbin]'):
			optPcbinShareFound = True
		elif (lines[i].lower().strip() == '[opsi_depot]'):
			depotShareFound = True
		elif (lines[i].lower().strip() == '[opsi_config]'):
			configShareFound = True
		elif (lines[i].lower().strip() == '[opsi_workbench]'):
			workbenchShareFound = True
		newlines.append(lines[i])
	
	if not optPcbinShareFound and (getSysConfig()['distribution'].lower().find('suse linux enterprise server') == -1):
		logger.notice(u"   Adding share [opt_pcbin]")
		confChanged = True
		newlines.append(u"[opt_pcbin]\n")
		newlines.append(u"   available = yes\n")
		newlines.append(u"   comment = opsi depot share\n")
		newlines.append(u"   path = /opt/pcbin\n")
		newlines.append(u"   oplocks = no\n")
		newlines.append(u"   follow symlinks = yes\n")
		newlines.append(u"   level2 oplocks = no\n")
		newlines.append(u"   writeable = yes\n")
		newlines.append(u"   invalid users = root\n")
		newlines.append(u"\n")
	
	if not depotShareFound:
		logger.notice(u"   Adding share [opsi_depot]")
		confChanged = True
		newlines.append(u"[opsi_depot]\n")
		newlines.append(u"   available = yes\n")
		newlines.append(u"   comment = opsi depot share (ro)\n")
		newlines.append(u"   path = /var/lib/opsi/depot\n")
		newlines.append(u"   oplocks = no\n")
		newlines.append(u"   level2 oplocks = no\n")
		newlines.append(u"   writeable = no\n")
		newlines.append(u"   invalid users = root\n")
		newlines.append(u"\n")
		link = '/var/lib/opsi/depot'
		source = '/opt/pcbin/install'
		if not os.path.exists(link) and os.path.exists(source):
			try:
				os.symlink(source, link)
			except Exception, e:
				logger.error(u"Failed to create symlink '%s' pointing to '%s': %s" % (link, source, e))
		
	if not configShareFound:
		logger.notice(u"   Adding share [opsi_config]")
		confChanged = True
		newlines.append(u"[opsi_config]\n")
		newlines.append(u"   available = yes\n")
		newlines.append(u"   comment = opsi config share\n")
		newlines.append(u"   path = /var/lib/opsi/config\n")
		newlines.append(u"   writeable = yes\n")
		newlines.append(u"   invalid users = root\n")
		newlines.append(u"\n")
		
	if not workbenchShareFound:
		logger.notice(u"   Adding share [opsi_workbench]")
		confChanged = True
		newlines.append(u"[opsi_workbench]\n")
		newlines.append(u"   available = yes\n")
		newlines.append(u"   comment = opsi workbench\n")
		if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
			newlines.append(u"   path = /var/lib/opsi/workbench\n")
		else:
			newlines.append(u"   path = /home/opsiproducts\n")
		newlines.append(u"   writeable = yes\n")
		newlines.append(u"   invalid users = root\n")
		newlines.append(u"   create mask = 0660\n")
		newlines.append(u"   directory mask = 0770\n")
		newlines.append(u"\n")
		
	if confChanged:
		logger.notice(u"   Creating backup of %s" % SMB_CONF)
		shutil.copy(SMB_CONF, SMB_CONF + u'.' + time.strftime("%Y-%m-%d_%H:%M"))
		
		logger.notice(u"   Writing new smb.conf")
		f = codecs.open(SMB_CONF, 'w', 'utf-8')
		lines = f.writelines(newlines)
		f.close()
		
		logger.notice(u"   Reloading samba")
		try:
			execute(u'%s reload' % SMB_INIT)
		except Exception, e:
			logger.warning(e)
		
	
def configureDHCPD():
	logger.notice(u"Configuring dhcpd")
	
	dhcpdConf = DHCPDConfFile(DHCPD_CONF)
	dhcpdConf.parse()
	
	confChanged = False
	if dhcpdConf.getGlobalBlock().getParameters_hash().get('use-host-decl-names', False):
		logger.info(u"   use-host-decl-names already enabled")
	else:
		confChanged = True
		dhcpdConf.getGlobalBlock().addComponent(
			DHCPDConf_Parameter(
				startLine 	= -1,
				parentBlock 	= dhcpdConf.getGlobalBlock(),
				key 		= 'use-host-decl-names',
				value 		= True ) )
	
	subnets = dhcpdConf.getGlobalBlock().getBlocks('subnet', recursive = True)
	if not subnets:
		confChanged = True
		logger.notice(u"   No subnets found, adding subnet")
		dhcpdConf.getGlobalBlock().addComponent(
			DHCPDConf_Block(
				startLine 	= -1,
				parentBlock 	= dhcpdConf.getGlobalBlock(),
				type 		= 'subnet',
				settings 	= ['subnet', getSysConfig()['subnet'], 'netmask', getSysConfig()['netmask']] ) )
	
	for subnet in dhcpdConf.getGlobalBlock().getBlocks('subnet', recursive = True):
		logger.info(u"   Found subnet %s/%s" % (subnet.settings[1], subnet.settings[3]))
		groups = subnet.getBlocks('group')
		if not groups:
			confChanged = True
			logger.notice(u"      No groups found, adding group")
			subnet.addComponent(
				DHCPDConf_Block(
					startLine 	= -1,
					parentBlock 	= subnet,
					type 		= 'group',
					settings 	= ['group'] ) )
		for group in subnet.getBlocks('group'):
			logger.info(u"      Configuring group")
			params = group.getParameters_hash(inherit = 'global')
			if params.get('next-server'):
				logger.info(u"         next-server already set")
			else:
				confChanged = True
				group.addComponent(
					DHCPDConf_Parameter(
						startLine 	= -1,
						parentBlock 	= group,
						key 		= 'next-server',
						value 		= getSysConfig()['ipAddress'] ) )
				logger.notice(u"   next-server set to %s" % getSysConfig()['ipAddress'])
			if params.get('filename'):
				logger.info(u"         filename already set")
			else:
				confChanged = True
				filename = 'linux/pxelinux.0'
				if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
					filename = 'opsi/pxelinux.0'
				group.addComponent(
					DHCPDConf_Parameter(
						startLine 	= -1,
						parentBlock 	= group,
						key 		= 'filename',
						value 		= filename ) )
				logger.notice(u"         filename set to %s" % filename)
	
	if confChanged:
		logger.notice(u"   Creating backup of %s" % DHCPD_CONF)
		shutil.copy(DHCPD_CONF, DHCPD_CONF + u'.' + time.strftime("%Y-%m-%d_%H:%M"))
		
		logger.notice(u"   Writing new %s" % DHCPD_CONF)
		dhcpdConf.generate()
		
		logger.notice(u"   Restarting dhcpd")
		try:
			execute(u'%s restart' % DHCPD_INIT)
		except Exception, e:
			logger.warning(e)
	
	logger.notice(u"Configuring sudoers")
	
	found = False
	f = codecs.open(SUDOERS, 'r', 'utf-8')
	lines = []
	for line in f.readlines():
		if (line.find('%s restart' % DHCPD_INIT) != -1):
			found = True
		lines.append(line)
	f.close()
	if not found:
		logger.notice(u"   Creating backup of %s" % SUDOERS)
		shutil.copy(SUDOERS, SUDOERS + u'.' + time.strftime("%Y-%m-%d_%H:%M"))
		
		logger.notice(u"   Adding sudoers entry for dhcpd restart")
		distributor = getSysConfig()['distributor']
		if (distributor.lower().find('redhat') != -1) or (distributor.lower().find('centos') != -1) or (distributor.lower().find('scientificsl') != -1) or (distributor.lower().find('sme') != -1):
			lines.append(u"Defaults:opsiconfd !requiretty\n")
		lines.append(u"opsiconfd ALL=NOPASSWD: %s restart\n" % DHCPD_INIT)
		logger.notice(u"   Writing new %s" % SUDOERS)
		f = codecs.open(SUDOERS, 'w', 'utf-8')
		f.writelines(lines)
		f.close()
	
	opsiconfdUid  = pwd.getpwnam(OPSICONFD_USER)[2]
	adminGroupGid = grp.getgrnam(ADMIN_GROUP)[2]
	os.chown(DHCPD_CONF, opsiconfdUid, adminGroupGid)
	os.chmod(DHCPD_CONF, 0664)
	
def configureClientUser():
	logger.notice(u"Configuring client user %s" % CLIENT_USER)
	
	clientUserHome = pwd.getpwnam(CLIENT_USER)[5]
	sshDir = os.path.join(clientUserHome, '.ssh')
	
	if os.path.exists(sshDir):
		shutil.rmtree(sshDir)
	
	idRsa = os.path.join(sshDir, u'id_rsa')
	idRsaPub = os.path.join(sshDir, u'id_rsa.pub')
	authorizedKeys = os.path.join(sshDir, u'authorized_keys')
	if not os.path.exists(sshDir):
		os.mkdir(sshDir)
	if not os.path.exists(idRsa):
		logger.notice(u"   Creating RSA private key for user %s in '%s'" % (CLIENT_USER, idRsa))
		execute(u"%s -N '' -t rsa -f %s" % ( which('ssh-keygen'), idRsa))
	if not os.path.exists(authorizedKeys):
		f = codecs.open(idRsaPub, 'r', 'utf-8')
		f2 = codecs.open(authorizedKeys, 'w', 'utf-8')
		f2.write(f.read())
		f2.close()
		f.close()
	setRights(sshDir)
	
	password = None
	backend = None
	try:
		from OPSI.Backend.BackendManager import BackendManager
		backend = BackendManager(
			dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
			backendConfigDir   = u'/etc/opsi/backends',
			extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
			depotBackend       = True
		)
		depot = backend.host_getObjects(type = 'OpsiDepotserver', id = getSysConfig()['fqdn'])[0]
		
		configserverId = None
		for configserver in backend.host_getObjects(type = 'OpsiConfigserver'):
			if (configserver.id == getSysConfig()['fqdn']):
				configserverId = None
				break
			else:
				configserverId = configserver.id
		
		if configserverId:
			try:
				jsonrpcBackend = JSONRPCBackend(address = configserverId, username = depot.id, password = depot.opsiHostKey)
				password = blowfishDecrypt(depot.opsiHostKey, jsonrpcBackend.user_getCredentials(username = u'pcpatch', hostId = depot.id)['password'])
				jsonrpcBackend.backend_exit()
			except Exception, e:
				logger.info(u"Failed to get client user (pcpatch) password from configserver: %s" % e)
		if not password:
			password = blowfishDecrypt(depot.opsiHostKey, backend.user_getCredentials(username = u'pcpatch', hostId = depot.id)['password'])
	except Exception, e:
		logger.info(u"Failed to get client user (pcpatch) password: %s" % e)
		password = randomString(12)
	if backend:
		backend.backend_exit()
	
	logger.addConfidentialString(password)
	execute('opsi-admin -d task setPcpatchPassword "%s"' % password)
	
def setRights(path=u'/'):
	logger.notice(u"Setting rights")
	basedir = path
	if not os.path.isdir(basedir):
		basedir = os.path.dirname(basedir)
	
	clientUserUid     = pwd.getpwnam(CLIENT_USER)[2]
	opsiconfdUid      = pwd.getpwnam(OPSICONFD_USER)[2]
	adminGroupGid     = grp.getgrnam(ADMIN_GROUP)[2]
	fileAdminGroupGid = grp.getgrnam(FILE_ADMIN_GROUP)[2]
	
	depotDir = ''
	dirnames = [u'/tftpboot/linux', u'/home/opsiproducts', u'/var/log/opsi', u'/etc/opsi', u'/var/lib/opsi']
	specialfiles = [u'setup.py', u'show_drivers.py', u'create_driver_links.py', u'opsi-deploy-client-agent', u'opsi-deploy-client-agent-old', u'winexe']
	if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
		dirnames = [u'/var/lib/tftpboot/opsi', u'/var/log/opsi', u'/etc/opsi', u'/var/lib/opsi', u'/var/lib/opsi/workbench']
	if not path.startswith('/etc') and not path.startswith('/tftpboot'):
		try:
			from OPSI.Backend.BackendManager import BackendManager
			backend = BackendManager(
				dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
				backendConfigDir   = u'/etc/opsi/backends',
				extensionConfigDir = u'/etc/opsi/backendManager/extend.d'
			)
			depot = backend.host_getObjects(type = 'OpsiDepotserver', id = getSysConfig()['fqdn'])
			backend.backend_exit()
			if depot:
				depot = depot[0]
				depotUrl = depot.getDepotLocalUrl()
				if not depotUrl.startswith('file:///'):
					raise Exception(u"Bad repository local url '%s'" % depotUrl)
				depotDir = depotUrl[7:]
				if os.path.exists(depotDir):
					logger.info(u"Local depot directory '%s' found" % depotDir)
					dirnames.append(depotDir)
		except Exception, e:
			logger.error(e)
	
	if basedir.startswith('/opt/pcbin/install'):
		found = False
		for dirname in dirnames:
			if dirname.startswith('/opt/pcbin/install'):
				found = True
				break
		if not found:
			dirnames.append('/opt/pcbin/install')
		
	for dirname in dirnames:
		if not dirname.startswith(basedir) and not basedir.startswith(dirname):
			continue
		uid  = opsiconfdUid
		gid  = fileAdminGroupGid
		fmod = 0660
		dmod = 0770
		
		isProduct = False
		if dirname not in (u'/var/lib/tftpboot/opsi', u'/tftpboot/linux', u'/var/log/opsi', u'/etc/opsi', u'/var/lib/opsi', u'/var/lib/opsi/workbench'):
			isProduct = True
		
		if dirname in (u'/var/lib/tftpboot/opsi', u'/tftpboot/linux'):
			fmod = 0664
			dmod = 0775
		if dirname in (u'/var/log/opsi', u'/etc/opsi'):
			gid = adminGroupGid
		if dirname in (u'/home/opsiproducts', '/var/lib/opsi/workbench'):
			uid = -1
			dmod = 02770
		if dirname in (depotDir,):
			dmod = 02770
		
		if os.path.isfile(path):
			logger.debug(u"Setting rights on file '%s'" % path)
			os.chown(path, uid, gid)
			if isProduct:
				os.chmod(path, (os.stat(path)[0] | 0660) & 0770)
			else:
				os.chmod(path, fmod)
			continue
		
		startPath = dirname
		if basedir.startswith(dirname):
			startPath = basedir
		
		logger.notice(u"Setting rights on directory '%s'" % startPath)
		os.chown(startPath, uid, gid)
		os.chmod(startPath, dmod)
		for f in findFiles(startPath, prefix = startPath, returnLinks = False):
			os.chown(f, uid, gid)
			if os.path.isdir(f):
				logger.debug(u"Setting rights on directory '%s'" % f)
				os.chmod(f, dmod)
			elif os.path.isfile(f):
				logger.debug(u"Setting rights on file '%s'" % f)
				if isProduct:
					if os.path.basename(f) in specialfiles:
						os.chmod(f, 0770)
					else:
						os.chmod(f, (os.stat(f)[0] | 0660) & 0770)
				else:
					os.chmod(f, fmod)
		
		if startPath.startswith(u'/var/lib/opsi'):
			os.chmod(u'/var/lib/opsi', 0750)
			os.chown(u'/var/lib/opsi', clientUserUid, fileAdminGroupGid)
			sshDir = u'/var/lib/opsi/.ssh'
			if os.path.exists(sshDir):
				os.chown(sshDir, clientUserUid, fileAdminGroupGid)
				os.chmod(sshDir, 0750)
				idRsa = os.path.join(sshDir, u'id_rsa')
				if os.path.exists(idRsa):
					os.chmod(idRsa, 0640)
					os.chown(idRsa, clientUserUid, fileAdminGroupGid)
				idRsaPub = os.path.join(sshDir, u'id_rsa.pub')
				if os.path.exists(idRsaPub):
					os.chmod(idRsaPub, 0644)
					os.chown(idRsaPub, clientUserUid, fileAdminGroupGid)
				authorizedKeys = os.path.join(sshDir, u'authorized_keys')
				if os.path.exists(authorizedKeys):
					os.chmod(authorizedKeys, 0600)
					os.chown(authorizedKeys, clientUserUid, fileAdminGroupGid)
			
def update(fromVersion = None):
	# 3.x => 4.x
	if os.path.exists(u'/var/lib/opsi/products'):
		logger.notice(u"Found /var/lib/opsi/products, moving to /var/lib/opsi/repository")
		if not os.path.exists(u'/var/lib/opsi/repository'):
			os.mkdir(u'/var/lib/opsi/repository')
		for f in os.listdir(u'/var/lib/opsi/products'):
			shutil.move(os.path.join(u'/var/lib/opsi/products', f), os.path.join(u'/var/lib/opsi/repository', f))
		try:
			os.rmdir(u'/var/lib/opsi/products')
		except Exception, e:
			logger.warning(e)
	
	isConfigServer = False
	try:
		bdc = BackendDispatchConfigFile(u'/etc/opsi/backendManager/dispatch.conf')
		dispatchConfig = bdc.parse()
		for entry in dispatchConfig:
			(regex, backends) = entry
			if not re.search(regex, 'backend_createBase'):
				continue
			if not 'jsonrpc' in backends:
				isConfigServer = True
			break
	except Exception, e:
		logger.warning(e)
	
	if isConfigServer:
		try:
			from OPSI.Backend.BackendManager import BackendManager
			backend = BackendManager(
				dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
				backendConfigDir   = u'/etc/opsi/backends',
				extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
				depotbackend       = False
			)
			backend.backend_createBase()
			backend.backend_exit()
		except Exception, e:
			logger.warning(e)
	
	# 4.0 => 4.0.1
	link = '/var/lib/opsi/depot'
	source = '/opt/pcbin/install'
	if not os.path.exists(link) and os.path.exists(source):
		try:
			os.symlink(source, link)
		except Exception, e:
			logger.warning(u"Failed to create symlink '%s' pointing to '%s': %s" % (link, source, e))
	
	if isConfigServer:
		initializeConfigs()
	configureSamba()

def updateUniventionBackend():
	return updateLDAPBackend(backendConfigFile = u'/etc/opsi/backends/univention.conf')

def updateLDAPBackend(backendConfigFile = u'/etc/opsi/backends/ldap.conf'):
	
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	logger.info(u"Loading backend config '%s'" % backendConfigFile)
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	baseDn = l['baseDn']
	logger.info(u"Current ldap backend config: %s" % config)
	
	logger.notice(u"Creating ldap backend instance")
	backend = ExtendedConfigDataBackend(LDAPBackend(**config))
	
	ldapSession = LDAPSession(address = config['address'], username = config['username'], password = config['password'])
	ldapSession.connect()
	
	logger.notice(u"Testing ldap schema")
	
	try:
		ldapObj = LDAPObject(u"cn=opsi-config-test,%s" % config['opsiBaseDn'])
		ldapObj.new("opsiProductOnClient")
		ldapObj.setAttribute('opsiProductId', ['test'])
		ldapObj.setAttribute('opsiClientId', ['test.domain.tld'])
		ldapObj.setAttribute('opsiProductType', ['LocalbootProduct'])
		ldapObj.writeToDirectory(ldapSession)
		ldapObj.deleteFromDirectory(ldapSession)
	except Exception, e:
		raise Exception(u'Test of opsi-ldap 4.0 schema failed: %s, Please verify opsi.schema and restart slapd.' % e)
	
	
	for container in ('configs', 'configStates', 'objectToGroups', 'productOnClients', 'productOnDepots', 'productPropertyStates'):
		ldapObj = LDAPObject(u"cn=%s,%s" % (container, config['opsiBaseDn']))
		if ldapObj.exists(ldapSession):
			logger.notice(u"Deleting container: %s" % ldapObj.getDn())
			ldapObj.deleteFromDirectory(ldapSession, recursive = True)
	
	backend.backend_createBase()
	
	logger.notice(u"Converting opsiHost")
	search = LDAPObjectSearch(ldapSession, baseDn, filter = u'(objectClass=opsiConfigserver)')
	for obj in search.getObjects():
		logger.info(u"Found config server: %s" % obj.getDn())
		try:
			obj.readFromDirectory(ldapSession)
			#hostId = forceHostId(obj.getCn())
			obj.removeObjectClass('opsiHost')
			obj.removeObjectClass('opsiDepotserver')
			obj.removeObjectClass('opsiConfigserver')
			obj.addObjectClass('OpsiHost')
			obj.addObjectClass('OpsiDepotserver')
			obj.addObjectClass('OpsiConfigserver')
			url = obj.getAttribute('opsiRepositoryLocalUrl', default = "", valuesAsList = False).replace(u'/products', u'/repository')
			obj.setAttribute('opsiRepositoryLocalUrl', [url])
			url = obj.getAttribute('opsiRepositoryRemoteUrl', default = "", valuesAsList = False).replace(u'/products', u'/repository')
			obj.setAttribute('opsiRepositoryRemoteUrl', [url])
			obj.setAttribute('opsiIsMasterDepot', ['TRUE'])
			obj.writeToDirectory(ldapSession)
		except Exception, e:
			obj.deleteFromDirectory(ldapSession)
			logger.error(e)
	
	search = LDAPObjectSearch(ldapSession, baseDn, filter = u'(objectClass=opsiDepotserver)')
	for obj in search.getObjects():
		logger.info(u"Found depot server: %s" % obj.getDn())
		try:
			obj.readFromDirectory(ldapSession)
			#hostId = forceHostId(obj.getCn())
			obj.removeObjectClass('opsiHost')
			obj.removeObjectClass('opsiDepotserver')
			obj.addObjectClass('OpsiHost')
			obj.addObjectClass('OpsiDepotserver')
			url = obj.getAttribute('opsiRepositoryLocalUrl', default = "", valuesAsList = False).replace(u'/products', u'/repository')
			obj.setAttribute('opsiRepositoryLocalUrl', [url])
			url = obj.getAttribute('opsiRepositoryRemoteUrl', default = "", valuesAsList = False).replace(u'/products', u'/repository')
			obj.setAttribute('opsiRepositoryRemoteUrl', [url])
			obj.setAttribute('opsiIsMasterDepot', ['TRUE'])
			obj.writeToDirectory(ldapSession)
		except Exception, e:
			obj.deleteFromDirectory(ldapSession)
			logger.error(e)
	
	search = LDAPObjectSearch(ldapSession, baseDn, filter = u'(objectClass=opsiClient)')
	for obj in search.getObjects():
		logger.info(u"Found client: %s" % obj.getDn())
		try:
			obj.readFromDirectory(ldapSession)
			#hostId = forceHostId(obj.getCn())
			obj.removeObjectClass('opsiHost')
			obj.removeObjectClass('opsiClient')
			obj.addObjectClass('OpsiHost')
			obj.addObjectClass('OpsiClient')
			obj.writeToDirectory(ldapSession)
		except Exception, e:
			obj.deleteFromDirectory(ldapSession)
			logger.error(e)
		
	serverIds = backend.host_getIdents(returnType = 'unicode', type = u'OpsiConfigserver')
	depotIds  = backend.host_getIdents(returnType = 'unicode', type = u'OpsiDepotserver')
	clientIds = backend.host_getIdents(returnType = 'unicode', type = u'OpsiClient')
	
	logger.notice(u"Converting opsiGeneralConfig")
	search = LDAPObjectSearch(ldapSession, config['opsiBaseDn'], filter = u'(objectClass=opsiGeneralConfig)')
	for obj in search.getObjects():
		try:
			obj.readFromDirectory(ldapSession)
			logger.info(u"Found general config: %s" % obj.getDn())
			hostId = forceHostId(obj.getCn())
			for opsiKeyValuePair in obj.getAttribute('opsiKeyValuePair', default = [], valuesAsList = True):
				try:
					logger.info(u"Converting general config: %s" % opsiKeyValuePair)
					(configId, value) = opsiKeyValuePair.split(u'=', 1)
					if   hostId in serverIds:
						backend.config_createObjects( UnicodeConfig(id = configId, defaultValues = [ value ]) )
					elif hostId in clientIds:
						backend.config_createObjects( UnicodeConfig(id = configId) )
						backend.configState_createObjects( ConfigState(configId = configId, objectId = hostId, values = [ value ] ) )
				except Exception, e:
					logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
		except Exception, e:
			logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	logger.notice(u"Converting opsiNetworkConfig")
	search = LDAPObjectSearch(ldapSession, config['opsiBaseDn'], filter = u'(objectClass=opsiNetworkConfig)')
	for obj in search.getObjects():
		try:
			obj.readFromDirectory(ldapSession)
			logger.info(u"Found network config: %s" % obj.getDn())
			hostId = forceHostId(obj.getCn())
			for (key, value) in obj.getAttributeDict(valuesAsList = False).items():
				try:
					if not value:
						continue
					configId = None
					multiValue = False
					if   (key == 'opsiDepotserverReference'):
						configId = u'clientconfig.depot.id'
						serverObj = LDAPObject(value)
						value = None
						if serverObj.exists(ldapSession):
							serverObj.readFromDirectory(ldapSession)
							try:
								value = forceHostId(serverObj.getAttribute('opsiHostId', default = None, valuesAsList = False))
							except Exception, e:
								logger.debug(e)
						if not value:
							continue
					elif (key == 'opsiDepotDrive'):
						configId = u'clientconfig.depot.drive'
					elif (key == 'opsiNextBootServiceURL'):
						configId = u'clientconfig.configserver.url'
						if (value.find('/rpc') == -1):
							value = value + '/rpc'
						multiValue = True
					elif (key == 'opsiWinDomain'):
						configId = u'clientconfig.windows.domain'
					
					if not configId:
						continue
					
					logger.info(u"Converting network config %s" % key)
					
					if   hostId in serverIds:
						backend.config_createObjects( UnicodeConfig(id = configId, defaultValues = [ value ], multiValue = multiValue) )
					elif hostId in clientIds:
						backend.config_createObjects( UnicodeConfig(id = configId, multiValue = multiValue) )
						backend.configState_createObjects( ConfigState(configId = configId, objectId = hostId, values = [ value ] ) )
				except Exception, e:
					logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
		except Exception, e:
			logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
			
	logger.notice(u"Converting opsiGroup")
	
	def convertGroupObject(obj, parentGroupId = None):
		try:
			groupId = forceGroupId(obj.getCn())
			
			search = LDAPObjectSearch(ldapSession, obj.getDn(), scope = ldap.SCOPE_ONELEVEL, filter = u'(objectClass=opsiGroup)')
			for obj2 in search.getObjects():
				convertGroupObject(obj2, parentGroupId = groupId)
			objectToGroups = []
			obj.readFromDirectory(ldapSession)
			for value in obj.getAttribute('uniqueMember', default = [], valuesAsList = True):
				try:
					hostObj = LDAPObject(value)
					value = None
					if hostObj.exists(ldapSession):
						hostObj.readFromDirectory(ldapSession)
						try:
							value = forceHostId(hostObj.getAttribute('opsiHostId', default = None, valuesAsList = False))
						except Exception, e:
							logger.debug(e)
					if not value:
						continue
					objectToGroups.append( ObjectToGroup(groupId = groupId, groupType = 'HostGroup', objectId = value) )
				except Exception, e:
					logger.error(u"Failure while processing group member %s of group %s: %s" % (value, obj.getDn(), e))
			obj.deleteFromDirectory(ldapSession)
			backend.group_createObjects( HostGroup(id = groupId, parentGroupId = parentGroupId) )
			backend.objectToGroup_createObjects(objectToGroups)
		except Exception, e:
			logger.error(u"Failure while processing group %s: %s" % (obj.getDn(), e))
	
	search = LDAPObjectSearch(ldapSession, "cn=groups,%s" % config['opsiBaseDn'], scope = ldap.SCOPE_ONELEVEL, filter = u'(objectClass=opsiGroup)')
	for obj in search.getObjects():
		convertGroupObject(obj)
	
	localbootProductIds = []
	netbootProductIds = []
	deleteDns = []
	for objectClass in ('opsiLocalBootProduct', 'opsiNetBootProduct'):
		logger.notice(u"Converting %s" % objectClass)
		search = LDAPObjectSearch(ldapSession, config['opsiBaseDn'], filter = u'(objectClass=%s)' % objectClass)
		for obj in search.getObjects():
			try:
				obj.readFromDirectory(ldapSession)
				logger.info(u"Found product: %s" % obj.getDn())
				
				depotId = forceHostId( obj.getDn().split(',')[1].split('=')[1] )
				containerDn = ','.join(obj.getDn().split(',')[1:])
				if not containerDn in deleteDns:
					deleteDns.append(containerDn)
				
				Class = LocalbootProduct
				if (objectClass == 'opsiNetBootProduct'):
					Class = NetbootProduct
				
				product = Class(
					id                 = obj.getCn(),
					productVersion     = obj.getAttribute('opsiProductVersion',         default = None, valuesAsList = False),
					packageVersion     = obj.getAttribute('opsiPackageVersion',         default = None, valuesAsList = False),
					name               = obj.getAttribute('opsiProductName',            default = None, valuesAsList = False),
					licenseRequired    = obj.getAttribute('opsiProductLicenseRequired', default = None, valuesAsList = False),
					setupScript        = obj.getAttribute('opsiSetupScript',            default = None, valuesAsList = False),
					uninstallScript    = obj.getAttribute('opsiUninstallScript',        default = None, valuesAsList = False),
					updateScript       = obj.getAttribute('opsiUpdateScript',           default = None, valuesAsList = False),
					alwaysScript       = obj.getAttribute('opsiAlwaysScript',           default = None, valuesAsList = False),
					onceScript         = obj.getAttribute('opsiOnceScript',             default = None, valuesAsList = False),
					priority           = obj.getAttribute('opsiProductPriority',        default = None, valuesAsList = False),
					description        = obj.getAttribute('description',                default = None, valuesAsList = False),
					advice             = obj.getAttribute('opsiProductAdvice',          default = None, valuesAsList = False),
					windowsSoftwareIds = obj.getAttribute('opsiWindowsSoftwareId',      default = None, valuesAsList = True)
				)
				if (objectClass == 'opsiNetBootProduct'):
					if not product.id in netbootProductIds:
						netbootProductIds.append(product.id)
					product.setPxeConfigTemplate( obj.getAttribute('opsiPxeConfigTemplate', default = None, valuesAsList = False) )
				else:
					if not product.id in localbootProductIds:
						localbootProductIds.append(product.id)
				
				backend.product_createObjects(product)
				
				backend.productOnDepot_createObjects(
					ProductOnDepot(
						productId      = product.getId(),
						productType    = product.getType(),
						productVersion = product.getProductVersion(),
						packageVersion = product.getPackageVersion(),
						depotId        = depotId,
						locked         = obj.getAttribute('opsiProductIsLocked', default = False, valuesAsList = False)
					)
				)
			except Exception, e:
				logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	
	logger.notice(u"Converting opsiProductPropertyDefinition")
	search = LDAPObjectSearch(ldapSession, config['opsiBaseDn'], filter = u'(objectClass=opsiProductPropertyDefinition)')
	for obj in search.getObjects():
		try:
			obj.readFromDirectory(ldapSession)
			logger.info(u"Found product property: %s" % obj.getDn())
			#obj.deleteFromDirectory(ldapSession, recursive = True)
			
			
			productId = forceProductId( obj.getDn().split(',')[2].split('=')[1] )
			depotId   = forceHostId( obj.getDn().split(',')[3].split('=')[1] )
			
			productOnDepot = backend.productOnDepot_getObjects(productId = productId, depotId = depotId)
			if not productOnDepot:
				raise Exception(u"Product '%s' not found on depot '%s'" % (productId, depotId))
			productOnDepot = productOnDepot[0]
			
			defaultValues  = obj.getAttribute('opsiProductPropertyDefaultValue',  default = None, valuesAsList = True)
			possibleValues = obj.getAttribute('opsiProductPropertyPossibleValue', default = None, valuesAsList = True)
			backend.productProperty_createObjects(
				UnicodeProductProperty(
					productId       = productOnDepot.productId,
					productVersion  = productOnDepot.productVersion,
					packageVersion  = productOnDepot.packageVersion,
					propertyId      = obj.getCn().replace(' ', '_'),
					description     = obj.getAttribute('description', default = None, valuesAsList = False),
					possibleValues  = possibleValues,
					defaultValues   = defaultValues,
					editable        = bool(possibleValues),
				)
			)
			if defaultValues:
				backend.productPropertyState_createObjects(
					ProductPropertyState(
						productId   = productOnDepot.productId,
						propertyId  = obj.getCn().replace(' ', '_'),
						objectId    = depotId,
						values      = defaultValues
					)
				)
		except Exception, e:
			logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	logger.notice(u"Converting opsiProductDependency")
	search = LDAPObjectSearch(ldapSession, config['opsiBaseDn'], filter = u'(objectClass=opsiProductDependency)')
	for obj in search.getObjects():
		try:
			obj.readFromDirectory(ldapSession)
			logger.info(u"Found product dependency: %s" % obj.getDn())
			
			#cn=javavm,cn=setup,cn=productDependencies,cn=ooffice3,cn=exp-srv-005.uib.local,cn=products,cn=opsi,dc=uib,dc=local
			requiredProductId = forceProductId(     obj.getDn().split(',')[0].split('=')[1] )
			action            = forceActionRequest( obj.getDn().split(',')[1].split('=')[1] )
			productId         = forceProductId(     obj.getDn().split(',')[3].split('=')[1] )
			depotId           = forceHostId(        obj.getDn().split(',')[4].split('=')[1] )
			
			productOnDepot = backend.productOnDepot_getObjects(productId = productId, depotId = depotId)
			if not productOnDepot:
				raise Exception(u"Product '%s' not found on depot '%s'" % (productId, depotId))
			productOnDepot = productOnDepot[0]
			
			backend.productDependency_createObjects(
				ProductDependency(
					productId                  = productOnDepot.productId,
					productVersion             = productOnDepot.productVersion,
					packageVersion             = productOnDepot.packageVersion,
					productAction              = action,
					requiredProductId          = requiredProductId,
					requiredAction             = obj.getAttribute('opsiActionRequired',             default = None, valuesAsList = False),
					requiredInstallationStatus = obj.getAttribute('opsiInstallationStatusRequired', default = None, valuesAsList = False),
					requirementType            = obj.getAttribute('opsiRequirementType',            default = None, valuesAsList = False)
				)
			)
		except Exception, e:
			logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	
	for deleteDn in deleteDns:
		try:
			logger.notice(u"Deleting %s" % deleteDn)
			LDAPObject(deleteDn).deleteFromDirectory(ldapSession, recursive = True)
		except Exception, e:
			logger.error(e)
	
	
	
	logger.notice(u"Converting opsiProductState")
	contSearch = LDAPObjectSearch(ldapSession, "cn=productStates,%s" % config['opsiBaseDn'], scope = ldap.SCOPE_ONELEVEL, filter = u'(objectClass=organizationalRole)')
	for contObj in contSearch.getObjects():
		search = LDAPObjectSearch(ldapSession, contObj.getDn(), filter = u'(objectClass=opsiProductState)')
		for obj in search.getObjects():
			try:
				obj.readFromDirectory(ldapSession)
				logger.info(u"Found product state: %s" % obj.getDn())
				
				productType = 'LocalbootProduct'
				if obj.getCn() in netbootProductIds:
					productType = 'NetbootProduct'
				
				actionRequest       = obj.getAttribute('opsiProductActionRequestForced', default = None, valuesAsList = False)
				installationStatus  = obj.getAttribute('opsiProductInstallationStatus', default = None, valuesAsList = False)
				actionProgress      = obj.getAttribute('opsiProductActionProgress', default = None, valuesAsList = False)
				actionResult        = None
				targetConfiguration = None
				
				if installationStatus in ('failed',):
					actionResult = 'failed'
					installationStatus = 'not_installed'
				if installationStatus in ('installing',):
					actionProgress = 'installing'
					installationStatus = 'not_installed'
				try:
					installationStatus = forceInstallationStatus(installationStatus)
				except:
					installationStatus = 'not_installed'
				try:
					actionRequest = forceActionRequest(actionRequest)
				except:
					actionRequest = 'none'
				
				if (actionProgress == '{}'):
					actionProgress = None
				
				if (installationStatus == 'not_installed') and (actionRequest == 'none') and actionResult is None:
					continue
				
				if (installationStatus == 'installed'):
					targetConfiguration = 'installed'
				
				clientId = forceHostId( obj.getDn().split(',')[1].split('=')[1] )
				if not clientId in clientIds:
					continue
				
				backend.productOnClient_insertObject(
					ProductOnClient(
						productId           = obj.getCn(),
						productType         = productType,
						productVersion      = obj.getAttribute('opsiProductVersion', default = None, valuesAsList = False),
						packageVersion      = obj.getAttribute('opsiPackageVersion', default = None, valuesAsList = False),
						clientId            = clientId,
						installationStatus  = installationStatus,
						targetConfiguration = targetConfiguration,
						actionRequest       = actionRequest,
						actionProgress      = actionProgress
					)
				)
			except Exception, e:
				logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	
	logger.notice(u"Converting opsiProductProperty")
	search = LDAPObjectSearch(ldapSession, u'cn=productProperties,%s' % config['opsiBaseDn'], filter = u'(objectClass=opsiProductProperty)')
	for obj in search.getObjects():
		try:
			obj.readFromDirectory(ldapSession)
			logger.info(u"Found product property: %s" % obj.getDn())
			
			clientId = forceHostId( obj.getDn().split(',')[1].split('=')[1] )
			if not clientId in clientIds:
				continue
			
			productId = obj.getAttribute('opsiProductReference', valuesAsList = False).split(',')[0].split('=')[1]
			
			productPropertyStates = []
			for opsiKeyValuePair in obj.getAttribute('opsiKeyValuePair', default = [], valuesAsList = True):
				try:
					logger.info(u"Converting product property: %s" % opsiKeyValuePair)
					(propertyId, value) = opsiKeyValuePair.split(u'=', 1)
					if (value == ''):
						continue
					productPropertyStates.append(
						ProductPropertyState(
							productId   = productId,
							propertyId  = propertyId.replace(' ', '_'),
							objectId    = clientId,
							values      = [ value ]
						)
					)
				except Exception, e:
					logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
			backend.productPropertyState_createObjects(productPropertyStates)
		except Exception, e:
			logger.error(u"Failure while processing %s: %s" % (obj.getDn(), e))
	
	
	for container in ('generalConfigs', 'networkConfigs', 'productClasses', 'productLicenses', 'productProperties', 'productStates'):
		ldapObj = LDAPObject(u"cn=%s,%s" % (container, config['opsiBaseDn']))
		if ldapObj.exists(ldapSession):
			logger.notice(u"Deleting container: %s" % ldapObj.getDn())
			ldapObj.deleteFromDirectory(ldapSession, recursive = True)

def updateMySQLBackend():
	backendConfigFile = u'/etc/opsi/backends/mysql.conf'
	
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	logger.info(u"Loading backend config '%s'" % backendConfigFile)
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	logger.info(u"Current mysql backend config: %s" % config)
	
	logger.notice(u"Connection to database '%s' on '%s' as user '%s'" % (config['database'], config['address'], config['username']))
	mysql = MySQL(**config)
	
	tables = {}
	logger.debug(u"Current tables:")
	for i in mysql.getSet(u'SHOW TABLES;'):
		tableName = i.values()[0]
		logger.debug(u" [ %s ]" % tableName)
		tables[tableName] = []
		mysql.execute("alter table `%s` convert to charset utf8 collate utf8_general_ci;" % tableName);
		for j in mysql.getSet(u'SHOW COLUMNS FROM `%s`' % tableName):
			logger.debug(u"      %s" % j)
			tables[tableName].append(j['Field'])
			
	if 'HOST' in tables.keys() and 'host_id' in tables['HOST']:
		logger.notice(u"Updating database table HOST from opsi 3.3 to 3.4")
		# SOFTWARE_CONFIG
		logger.notice(u"Updating table SOFTWARE_CONFIG")
		mysql.execute(u"alter table SOFTWARE_CONFIG add `hostId` varchar(50) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE_CONFIG add `softwareId` varchar(100) NOT NULL;")
		for res in mysql.getSet(u"SELECT hostId,host_id FROM `HOST` WHERE `hostId` != ''"):
			mysql.execute(u"update SOFTWARE_CONFIG set `hostId`='%s' where `host_id`=%s;" % (res['hostId'].replace("'", "\\'"), res['host_id']))
		for res in mysql.getSet(u"SELECT softwareId,software_id FROM `SOFTWARE` WHERE `softwareId` != ''"):
			mysql.execute(u"update SOFTWARE_CONFIG set `softwareId`='%s' where `software_id`=%s;" % (res['softwareId'].replace("'", "\\'"), res['software_id']))
		mysql.execute(u"alter table SOFTWARE_CONFIG drop `host_id`;")
		mysql.execute(u"alter table SOFTWARE_CONFIG drop `software_id`;")
		mysql.execute(u"alter table SOFTWARE_CONFIG DEFAULT CHARACTER set utf8;")
		mysql.execute(u"alter table SOFTWARE_CONFIG ENGINE = InnoDB;")
	
	for key in tables.keys():
		# HARDWARE_CONFIG
		if key.startswith(u'HARDWARE_CONFIG') and 'host_id' in tables[key]:
			logger.notice(u"Updating database table %s from opsi 3.3 to 3.4" % key)
			mysql.execute(u"alter table %s add `hostId` varchar(50) NOT NULL;" % key)
			for res in mysql.getSet(u"SELECT hostId,host_id FROM `HOST` WHERE `hostId` != ''"):
				mysql.execute(u"update %s set `hostId` = '%s' where `host_id` = %s;" % (key, res['hostId'].replace("'", "\\'"), res['host_id']))
			mysql.execute(u"alter table %s drop `host_id`;" % key)
			mysql.execute(u"alter table %s DEFAULT CHARACTER set utf8;" % key)
			mysql.execute(u"alter table %s ENGINE = InnoDB;" % key)
	
	if 'HARDWARE_INFO' in tables.keys() and 'host_id' in tables['HARDWARE_INFO']:
		logger.notice(u"Updating database table HARDWARE_INFO from opsi 3.3 to 3.4")
		# HARDWARE_INFO
		logger.notice(u"Updating table HARDWARE_INFO")
		mysql.execute(u"alter table HARDWARE_INFO add `hostId` varchar(50) NOT NULL;")
		for res in mysql.getSet(u"SELECT hostId,host_id FROM `HOST` WHERE `hostId` != ''"):
			mysql.execute(u"update HARDWARE_INFO set `hostId` = '%s' where `host_id` = %s;" % (res['hostId'].replace("'", "\\'"), res['host_id']))
		mysql.execute(u"alter table HARDWARE_INFO drop `host_id`;")
		mysql.execute(u"alter table HARDWARE_INFO DEFAULT CHARACTER set utf8;")
		mysql.execute(u"alter table HARDWARE_INFO ENGINE = InnoDB;")
	
	if 'SOFTWARE' in tables.keys() and 'software_id' in tables['SOFTWARE']:
		logger.notice(u"Updating database table SOFTWARE from opsi 3.3 to 3.4")
		# SOFTWARE
		logger.notice(u"Updating table SOFTWARE")
		# remove duplicates
		mysql.execute("delete S1 from SOFTWARE S1, SOFTWARE S2 where S1.softwareId=S2.softwareId and S1.software_id > S2.software_id")
		mysql.execute(u"alter table SOFTWARE drop `software_id`;")
		mysql.execute(u"alter table SOFTWARE add primary key (`softwareId`);")
	
	if 'HOST' in tables.keys() and 'host_id' in tables['HOST']:
		logger.notice(u"Updating database table HOST from opsi 3.3 to 3.4")
		# HOST
		logger.notice(u"Updating table HOST")
		# remove duplicates
		mysql.execute("delete H1 from HOST H1, HOST H2 where H1.hostId=H2.hostId and H1.host_id > H2.host_id")
		mysql.execute(u"alter table HOST drop `host_id`;")
		mysql.execute(u"alter table HOST add primary key (`hostId`);")
		mysql.execute(u"alter table HOST add `type` varchar(20);")
		mysql.execute(u"alter table HOST add `description` varchar(100);")
		mysql.execute(u"alter table HOST add `notes` varchar(500);")
		mysql.execute(u"alter table HOST add `hardwareAddress` varchar(17);")
		mysql.execute(u"alter table HOST add `lastSeen` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';")
		mysql.execute(u"alter table HOST DEFAULT CHARACTER set utf8;")
		mysql.execute(u"alter table HOST ENGINE = InnoDB;")
		
		mysql.execute(u"update HOST set `type` = 'OPSI_CLIENT' where `hostId` != '';")
	
	tables = {}
	logger.debug(u"Current tables:")
	for i in mysql.getSet(u'SHOW TABLES;'):
		tableName = i.values()[0]
		logger.debug(u" [ %s ]" % tableName)
		tables[tableName] = []
		for j in mysql.getSet(u'SHOW COLUMNS FROM `%s`' % tableName):
			logger.debug(u"      %s" % j)
			tables[tableName].append(j['Field'])
	
	if 'HOST' in tables.keys() and not 'depotLocalUrl' in tables['HOST']:
		logger.notice(u"Updating database table HOST from opsi 3.4 to 4.0")
		# HOST
		logger.notice(u"Updating table HOST")
		mysql.execute(u"alter table HOST modify `hostId` varchar(255) NOT NULL;")
		mysql.execute(u"alter table HOST modify `type` varchar(30);")
		
		mysql.execute(u"alter table HOST add `ipAddress` varchar(15);")
		mysql.execute(u"alter table HOST add `inventoryNumber` varchar(30);")
		mysql.execute(u"alter table HOST add `created` TIMESTAMP;")
		mysql.execute(u"alter table HOST add `opsiHostKey` varchar(32);")
		mysql.execute(u"alter table HOST add `oneTimePassword` varchar(32);")
		mysql.execute(u"alter table HOST add `maxBandwidth` int;")
		mysql.execute(u"alter table HOST add `depotLocalUrl` varchar(128);")
		mysql.execute(u"alter table HOST add `depotRemoteUrl` varchar(255);")
		mysql.execute(u"alter table HOST add `depotWebdavUrl` varchar(255);")
		mysql.execute(u"alter table HOST add `repositoryLocalUrl` varchar(128);")
		mysql.execute(u"alter table HOST add `repositoryRemoteUrl` varchar(255);")
		mysql.execute(u"alter table HOST add `networkAddress` varchar(31);")
		mysql.execute(u"alter table HOST add `isMasterDepot` bool;")
		mysql.execute(u"alter table HOST add `masterDepotId` varchar(255);")
		
		mysql.execute(u"update HOST set `type`='OpsiClient' where `type`='OPSI_CLIENT';")
		mysql.execute(u"update HOST set `description`=NULL where `description`='None';")
		mysql.execute(u"update HOST set `notes`=NULL where `notes`='None';")
		mysql.execute(u"update HOST set `hardwareAddress`=NULL where `hardwareAddress`='None';")
		
		mysql.execute(u"alter table HOST add INDEX(`type`);")
		
	for key in tables.keys():
		if key.startswith(u'HARDWARE_DEVICE'):
			if not 'vendorId' in tables[key]:
				continue
			
			logger.notice(u"Updating database table %s from opsi 3.4 to 4.0" % key)
			for vendorId in ('NDIS', 'SSTP', 'AGIL', 'L2TP', 'PPTP', 'PPPO', 'PTIM'):
				mysql.execute(u"update %s set `vendorId`=NULL where `vendorId`='%s';" % (key, vendorId))
			
			for attr in ('vendorId', 'deviceId', 'subsystemVendorId', 'subsystemDeviceId'):
				if not attr in tables[key]:
					continue
				mysql.execute(u"update %s set `%s`=NULL where `%s`='';" % (key, attr, attr))
				mysql.execute(u"update %s set `%s`=NULL where `%s`='None';" % (key, attr, attr))
				
			for res in mysql.getSet(u"SELECT * FROM %s" % key):
				if res.get('vendorId'):
					try:
						forceHardwareVendorId(res['vendorId'])
					except:
						logger.warning(u"Dropping bad vendorId '%s'" % res['vendorId'])
						mysql.execute(u"update %s set `vendorId`=NULL where `vendorId`='%s';" % (key, res['vendorId']))
				if res.get('subsystemVendorId'):
					try:
						forceHardwareVendorId(res['subsystemVendorId'])
					except:
						logger.warning(u"Dropping bad subsystemVendorId id '%s'" % res['subsystemVendorId'])
						mysql.execute(u"update %s set `subsystemVendorId`=NULL where `subsystemVendorId`='%s';" % (key, res['subsystemVendorId']))
				if res.get('deviceId'):
					try:
						forceHardwareDeviceId(res['deviceId'])
					except:
						logger.warning(u"Dropping bad deviceId '%s'" % res['deviceId'])
						mysql.execute(u"update %s set `deviceId`=NULL where `deviceId`='%s';" % (key, res['deviceId']))
				if res.get('subsystemDeviceId'):
					try:
						forceHardwareDeviceId(res['subsystemDeviceId'])
					except:
						logger.warning(u"Dropping bad subsystemDeviceId '%s'" % res['subsystemDeviceId'])
						mysql.execute(u"update %s set `subsystemDeviceId`=NULL where `subsystemDeviceId`='%s';" % (key, res['subsystemDeviceId']))
					
		# HARDWARE_CONFIG
		if key.startswith(u'HARDWARE_CONFIG') and 'audit_lastseen' in tables[key]:
			logger.notice(u"Updating database table %s from opsi 3.4 to 4.0" % key)
			
			mysql.execute(u"alter table %s change `audit_firstseen` `firstseen` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';" % key)
			mysql.execute(u"alter table %s change `audit_lastseen` `lastseen` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';" % key)
			mysql.execute(u"alter table %s change `audit_state` `state` TINYINT NOT NULL;" % key)
	
	if 'LICENSE_USED_BY_HOST' in tables.keys():
		# LICENSE_ON_CLIENT
		logger.notice(u"Updating table LICENSE_USED_BY_HOST to LICENSE_ON_CLIENT")
		mysql.execute(u'''CREATE TABLE `LICENSE_ON_CLIENT` (
					`license_on_client_id` int NOT NULL AUTO_INCREMENT,
					PRIMARY KEY( `license_on_client_id` ),
					`softwareLicenseId` VARCHAR(100) NOT NULL,
					`licensePoolId` VARCHAR(100) NOT NULL,
					`clientId` varchar(255),
					FOREIGN KEY( `softwareLicenseId`, `licensePoolId` ) REFERENCES SOFTWARE_LICENSE_TO_LICENSE_POOL( `softwareLicenseId`, `licensePoolId` ),
					INDEX( `clientId` ),
					`licenseKey` VARCHAR(100),
					`notes` VARCHAR(1024)
				) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				''')
		
		mysql.execute(u"insert into LICENSE_ON_CLIENT (`softwareLicenseId`, `licensePoolId`, `clientId`, `licenseKey`, `notes`) select `softwareLicenseId`, `licensePoolId`, `hostId`, `licenseKey`, `notes` from LICENSE_USED_BY_HOST where `softwareLicenseId` != ''")
		mysql.execute(u"drop table LICENSE_USED_BY_HOST")
		
	if 'SOFTWARE' in tables.keys() and not 'name' in tables['SOFTWARE']:
		logger.notice(u"Updating database table SOFTWARE from opsi 3.4 to 4.0")
		# SOFTWARE
		logger.notice(u"Updating table SOFTWARE")
		mysql.execute(u"alter table SOFTWARE add `name` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `version` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `subVersion` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `language` varchar(10) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `architecture` varchar(3) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `windowsSoftwareId` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `windowsDisplayName` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `windowsDisplayVersion` varchar(100) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE add `type` varchar(30) NOT NULL;")
		for res in mysql.getSet(u"SELECT * FROM `SOFTWARE`"):
			name = res['displayName']
			if not name:
				name = res['softwareId']
			name = name.replace("'", "\\'")
			
			version = u''
			if res['displayVersion']:
				version = res['displayVersion'].replace("'", "\\'")
			
			res2 = mysql.getSet(u"SELECT * FROM `SOFTWARE` where `name` = '%s' and version ='%s'" % (name, version))
			if res2:
				logger.warning(u"Skipping duplicate: %s" % res2)
				mysql.execute(u"DELETE FROM `SOFTWARE` where `softwareId` = '%s'" % res['softwareId'].replace("'", "\\'"))
				continue
			
			update =  u"update SOFTWARE set"
			update += u"  `type`='AuditSoftware'"
			update += u", `windowsSoftwareId`='%s'"     % res['softwareId'].replace("'", "\\'")
			if res['displayName'] is not None:
				update += u", `windowsDisplayName`='%s'"    % res['displayName'].replace("'", "\\'")
			if res['displayVersion'] is not None:
				update += u", `windowsDisplayVersion`='%s'" % res['displayVersion'].replace("'", "\\'")
			update += u", `architecture`='x86'"
			update += u", `language`=''"
			update += u", `name`='%s'" % name
			update += u", `version`='%s'" % version
			update += u", `subVersion`=''"
			update += u" where `softwareId`='%s';" % res['softwareId'].replace("'", "\\'")
			mysql.execute(update)

		mysql.execute(u"alter table SOFTWARE drop PRIMARY KEY;")
		mysql.execute(u"alter table SOFTWARE add PRIMARY KEY ( `name`, `version`, `subVersion`, `language`, `architecture` );")
		mysql.execute(u"alter table SOFTWARE drop `softwareId`;")
		mysql.execute(u"alter table SOFTWARE drop `displayName`;")
		mysql.execute(u"alter table SOFTWARE drop `displayVersion`;")
		mysql.execute(u"alter table SOFTWARE drop `uninstallString`;")
		mysql.execute(u"alter table SOFTWARE drop `binaryName`;")
		
		mysql.execute(u"alter table SOFTWARE add INDEX( `windowsSoftwareId` );")
		mysql.execute(u"alter table SOFTWARE add INDEX( `type` );")
		
	if 'SOFTWARE_CONFIG' in tables.keys() and not 'clientId' in tables['SOFTWARE_CONFIG']:
		logger.notice(u"Updating database table SOFTWARE_CONFIG from opsi 3.4 to 4.0")
		# SOFTWARE_CONFIG
		logger.notice(u"Updating table SOFTWARE_CONFIG")

		mysql.execute(u"alter table SOFTWARE_CONFIG 	change `hostId` `clientId` varchar(255) NOT NULL, \
				add `name` varchar(100) NOT NULL, \
				add `version` varchar(100) NOT NULL, \
				add `subVersion` varchar(100) NOT NULL, \
				add `language` varchar(10) NOT NULL, \
				add `architecture` varchar(3) NOT NULL, \
				add `uninstallString` varchar(200), \
				add `binaryName` varchar(100), \
				change `audit_firstseen` `firstseen` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00', \
				change `audit_lastseen` `lastseen` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00', \
				change `audit_state` `state` TINYINT NOT NULL, \
				add `licenseKey` varchar(100), \
				add INDEX( `clientId` ), \
				add INDEX( `name`, `version`, `subVersion`, `language`, `architecture` );")

		mysql.execute(u"UPDATE SOFTWARE_CONFIG as sc \
				LEFT JOIN (select windowsSoftwareId, name, version, subVersion, language, architecture from SOFTWARE group by windowsSoftwareId) \
				as s on s.windowsSoftwareId = sc.softwareId \
				set sc.name = s.name, sc.version = s.version, sc.subVersion = s.subVersion, sc.architecture = s.architecture \
				where s.windowsSoftwareId is not null;")
		
		mysql.execute(u"delete from SOFTWARE_CONFIG where `name` = '';")
		mysql.execute(u"alter table SOFTWARE_CONFIG drop `softwareId`;")
		
	if 'LICENSE_CONTRACT' in tables.keys() and not 'type' in tables['LICENSE_CONTRACT']:
		logger.notice(u"Updating database table LICENSE_CONTRACT from opsi 3.4 to 4.0")
		# LICENSE_CONTRACT
		mysql.execute(u"alter table LICENSE_CONTRACT add `type` varchar(30) NOT NULL;")
		mysql.execute(u"alter table LICENSE_CONTRACT add `description` varchar(100) NOT NULL;")
		mysql.execute(u"alter table LICENSE_CONTRACT modify `conclusionDate` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';")
		mysql.execute(u"alter table LICENSE_CONTRACT modify `notificationDate` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';")
		mysql.execute(u"alter table LICENSE_CONTRACT modify `expirationDate` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';")
		mysql.execute(u"update LICENSE_CONTRACT set `type`='LicenseContract' where 1=1")
		
		mysql.execute(u"alter table LICENSE_CONTRACT add INDEX( `type` );")
		
	if 'SOFTWARE_LICENSE' in tables.keys() and not 'type' in tables['SOFTWARE_LICENSE']:
		logger.notice(u"Updating database table SOFTWARE_LICENSE from opsi 3.4 to 4.0")
		# SOFTWARE_LICENSE
		mysql.execute(u"alter table SOFTWARE_LICENSE add `type` varchar(30) NOT NULL;")
		mysql.execute(u"alter table SOFTWARE_LICENSE modify `expirationDate` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00';")
		mysql.execute(u"alter table SOFTWARE_LICENSE modify `boundToHost` varchar(255);")
		mysql.execute(u"update SOFTWARE_LICENSE set `type`='RetailSoftwareLicense' where `licenseType`='RETAIL'")
		mysql.execute(u"update SOFTWARE_LICENSE set `type`='OEMSoftwareLicense' where `licenseType`='OEM'")
		mysql.execute(u"update SOFTWARE_LICENSE set `type`='VolumeSoftwareLicense' where `licenseType`='VOLUME'")
		mysql.execute(u"update SOFTWARE_LICENSE set `type`='ConcurrentSoftwareLicense' where `licenseType`='CONCURRENT'")
		mysql.execute(u"alter table SOFTWARE_LICENSE drop `licenseType`;")
		
		mysql.execute(u"alter table SOFTWARE_LICENSE add INDEX( `type` );")
		mysql.execute(u"alter table SOFTWARE_LICENSE add INDEX( `boundToHost` );")
		
	if 'LICENSE_POOL' in tables.keys() and not 'type' in tables['LICENSE_POOL']:
		logger.notice(u"Updating database table LICENSE_POOL from opsi 3.4 to 4.0")
		# LICENSE_POOL
		mysql.execute(u"alter table LICENSE_POOL add `type` varchar(30) NOT NULL;")
		mysql.execute(u"update LICENSE_POOL set `type`='LicensePool' where 1=1")
		
		mysql.execute(u"alter table LICENSE_POOL add INDEX( `type` );")
	
	if 'WINDOWS_SOFTWARE_ID_TO_LICENSE_POOL' in tables.keys():
		# AUDIT_SOFTWARE_TO_LICENSE_POOL
		logger.notice(u"Updating table WINDOWS_SOFTWARE_ID_TO_LICENSE_POOL to AUDIT_SOFTWARE_TO_LICENSE_POOL")
		
		mysql.execute(u'''CREATE TABLE `AUDIT_SOFTWARE_TO_LICENSE_POOL` (
					`licensePoolId` VARCHAR(100) NOT NULL,
					FOREIGN KEY ( `licensePoolId` ) REFERENCES LICENSE_POOL( `licensePoolId` ),
					`name` varchar(100) NOT NULL,
					`version` varchar(100) NOT NULL,
					`subVersion` varchar(100) NOT NULL,
					`language` varchar(10) NOT NULL,
					`architecture` varchar(3) NOT NULL,
					PRIMARY KEY( `name`, `version`, `subVersion`, `language`, `architecture` )
				) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				''')
		
		for res in mysql.getSet(u"SELECT * FROM `WINDOWS_SOFTWARE_ID_TO_LICENSE_POOL`"):
			res2 = mysql.getSet(u"SELECT * FROM `SOFTWARE` where `windowsSoftwareId` = '%s'" % res['windowsSoftwareId'].replace("'", "\\'"))
			if not res2:
				continue
			res2 = res2[0]
			mysql.execute(u"insert into AUDIT_SOFTWARE_TO_LICENSE_POOL (`licensePoolId`, `name`, `version`, `subVersion`, `language`, `architecture`) VALUES ('%s', '%s', '%s', '%s', '%s', '%s');" \
					% (res['licensePoolId'], res2['name'].replace("'", "\\'"), res2['version'].replace("'", "\\'"), res2['subVersion'].replace("'", "\\'"), res2['language'], res2['architecture']) )
		
		mysql.execute(u"drop table WINDOWS_SOFTWARE_ID_TO_LICENSE_POOL;")
	
	
	for res in mysql.getSet(u"SELECT * FROM `LICENSE_CONTRACT`"):
		if (res['licenseContractId'] != forceLicenseContractId(res['licenseContractId'])):
			deleteLicenseContractId = res['licenseContractId']
			res['licenseContractId'] = forceLicenseContractId(res['licenseContractId'])
			logger.warning(u"Changing license contract id '%s' to '%s'" % (deleteLicenseContractId, res['licenseContractId']))
			
			data = {
				'SOFTWARE_LICENSE': [],
				'LICENSE_ON_CLIENT': [],
				'SOFTWARE_LICENSE_TO_LICENSE_POOL': []
			}
			for res2 in mysql.getSet(u"SELECT * FROM `SOFTWARE_LICENSE` where licenseContractId = '%s'" % deleteLicenseContractId):
				res2['licenseContractId'] = res['licenseContractId']
				data['SOFTWARE_LICENSE'].append(res2)
				for tab in ('LICENSE_ON_CLIENT', 'SOFTWARE_LICENSE_TO_LICENSE_POOL'):
					for res3 in mysql.getSet(u"SELECT * FROM `%s` where softwareLicenseId = '%s'" % (tab, res2['softwareLicenseId'])):
						data[tab].append(res3)
					mysql.delete(tab, "softwareLicenseId = '%s'" % res2['softwareLicenseId'])
			mysql.delete('SOFTWARE_LICENSE', "licenseContractId = '%s'" % deleteLicenseContractId)
			mysql.delete('LICENSE_CONTRACT', "licenseContractId = '%s'" % deleteLicenseContractId)
			mysql.insert('LICENSE_CONTRACT', res)
			for tab in ('SOFTWARE_LICENSE', 'SOFTWARE_LICENSE_TO_LICENSE_POOL', 'LICENSE_ON_CLIENT'):
				for i in data[tab]:
					mysql.insert(tab, i)
			
	for res in mysql.getSet(u"SELECT * FROM `LICENSE_POOL`"):
		if (res['licensePoolId'] != res['licensePoolId'].strip()) or (res['licensePoolId'] != forceLicensePoolId(res['licensePoolId'])):
			deleteLicensePoolId = res['licensePoolId']
			res['licensePoolId'] = forceLicensePoolId(res['licensePoolId'].strip())
			logger.warning(u"Changing license pool id '%s' to '%s'" % (deleteLicensePoolId, res['licensePoolId']))
			
			data = {}
			for tab in ('AUDIT_SOFTWARE_TO_LICENSE_POOL', 'PRODUCT_ID_TO_LICENSE_POOL', 'LICENSE_ON_CLIENT', 'SOFTWARE_LICENSE_TO_LICENSE_POOL'):
				data[tab] = []
				for res2 in mysql.getSet(u"SELECT * FROM `%s` where licensePoolId = '%s'" % (tab, deleteLicensePoolId)):
					res2['licensePoolId'] = res['licensePoolId']
					data[tab].append(res2)
				mysql.delete(tab, "licensePoolId = '%s'" % deleteLicensePoolId)
			
			mysql.delete('LICENSE_POOL', "licensePoolId = '%s'" % deleteLicensePoolId)
			mysql.insert('LICENSE_POOL', res)
			for tab in ('AUDIT_SOFTWARE_TO_LICENSE_POOL', 'PRODUCT_ID_TO_LICENSE_POOL', 'SOFTWARE_LICENSE_TO_LICENSE_POOL', 'LICENSE_ON_CLIENT'):
				for i in data[tab]:
					mysql.insert(tab, i)
			
	for res in mysql.getSet(u"SELECT * FROM `SOFTWARE_LICENSE`"):
		if (res['softwareLicenseId'] != res['softwareLicenseId'].strip()) or (res['softwareLicenseId'] != forceSoftwareLicenseId(res['softwareLicenseId'])):
			deleteSoftwareLicenseId = res['softwareLicenseId']
			res['softwareLicenseId'] = forceSoftwareLicenseId(res['softwareLicenseId'].strip())
			logger.warning(u"Changing software license id '%s' to '%s'" % (deleteSoftwareLicenseId, res['softwareLicenseId']))
			
			data = {}
			for tab in ('LICENSE_ON_CLIENT', 'SOFTWARE_LICENSE_TO_LICENSE_POOL'):
				data[tab] = []
				for res2 in mysql.getSet(u"SELECT * FROM `%s` where softwareLicenseId = '%s'" % (tab, deleteSoftwareLicenseId)):
					res2['softwareLicenseId'] = res['softwareLicenseId']
					data[tab].append(res2)
				mysql.delete(tab, "softwareLicenseId = '%s'" % deleteSoftwareLicenseId)
			
			mysql.delete('SOFTWARE_LICENSE', "softwareLicenseId = '%s'" % deleteSoftwareLicenseId)
			mysql.insert('SOFTWARE_LICENSE', res)
			for tab in ('SOFTWARE_LICENSE_TO_LICENSE_POOL', 'LICENSE_ON_CLIENT'):
				for i in data[tab]:
					mysql.insert(tab, i)
			
	mysqlBackend = MySQLBackend(**config)
	mysqlBackend.backend_createBase()
	mysqlBackend.backend_exit()



def updateFileBackend():
	backendConfigFile = u'/etc/opsi/backends/file.conf'
	
	if not os.path.isfile(backendConfigFile):
		raise Exception("Configuration file does not exist: '%s'" % (backendConfigFile))
	
	logger.notice(u"Loading backend config '%s'" % backendConfigFile)
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	logger.info(u"Current file backend config: %s" % config)
	
	#test for version 40
	newConfigFile = os.path.join(os.path.dirname(config["baseDir"]), u'config', u'config.ini')
	if os.path.isfile(newConfigFile):
		raise Exception(u"Detected a file ('%s') that should only be in opsi version 4.0, update denied!" % (newConfigFile))
	
	logger.notice(u"Creating file backend instance")
	backend = ExtendedConfigDataBackend(FileBackend(**config))
	
	backupDir = os.path.join(os.path.dirname(config["baseDir"]), u'backup_%s' % time.time())
	
	backupClientConfigDir   = os.path.join(backupDir, u'clients')
	backupDepotConfigDir    = os.path.join(backupDir, u'depots')
#	backupProductDir        = os.path.join(backupDir, u'products')
#	backupAuditDir          = os.path.join(backupDir, u'audit')
#	backupClientTemplateDir = os.path.join(backupDir, u'templates')
	
	logger.notice(u"Backing up current directory '%s' to '%s'" % (config["baseDir"], backupDir))
	if not os.path.isdir(config["baseDir"]):
		raise Exception("Base directory given from file '%s' does not exist: '%s'" % (backendConfigFile, config["baseDir"]))
	
	noClientDir = False
	if not os.path.isdir(os.path.join(config["baseDir"], u'clients')):
		noClientDir = True
		logger.warning("Client directory does not exist: '%s'" % (os.path.join(config["baseDir"], u'clients')))

	noDepotDir = False
	if not os.path.isdir(os.path.join(config["baseDir"], u'depots')):
		noDepotDir = True
		logger.warning("Depot directory does not exist: '%s'" % (os.path.join(config["baseDir"], u'depots')))
	
	
	
	shutil.move(config["baseDir"], backupDir)
	
	backend.backend_createBase()
	
	
	
	opsiHostKeys = {}
	if os.path.isfile(config["hostKeyFile"]):
		logger.notice(u"Backing up hostKeyFile '%s' to '%s'" % (config["hostKeyFile"], backupDir))
		shutil.copy(config["hostKeyFile"], backupDir)
		lines = []
		f = codecs.open(config["hostKeyFile"], 'r', 'utf-8')
		for line in f.readlines():
			line = line.strip()
			if not line:
				continue
			if line[0] in ('#', ';'):
				continue
			try:
				(hostId, key) = line.strip().split(':')
				hostId = forceHostId(hostId.replace('_', '-'))
			except Exception, e:
				logger.error(u"Bad line in %s: '%s': %s" % (config["hostKeyFile"], line, e))
				continue
			lines.append(u"%s:%s\n" % (hostId, key))
		f.close()
		f = codecs.open(config["hostKeyFile"], 'w', 'utf-8')
		f.writelines(lines)
		f.close()
		opsiHostKeys = HostKeyFile(filename = config["hostKeyFile"]).parse()
		os.remove(config["hostKeyFile"])
	else:
		logger.warning(u"Host key file does not exist: '%s'" % (config["hostKeyFile"]))
	
	
	lockedList = {}
	if os.path.isfile(os.path.join(backupDepotConfigDir, u'product.locks')):
		logger.info(u"Getting information on product.locks" % ())
		try:
			iniFile = IniFile(filename = os.path.join(backupDepotConfigDir, u'product.locks'), ignoreCase = False)
			ini = iniFile.parse()
			
			for proId in ini.sections():
				for depId in ini.options(proId):
					if (ini.get(proId, depId) == u'locked'):
						key = u'%s' % (proId.lower() + '#' + depId.lower())
						lockedList[key] = True
		except Exception, e:
			logger.error(u"Could not get all information on product.locks: %s" % (e))
	else:
		logger.warning(u"Product locks fils does not exist: '%s'" % (os.path.join(backupDepotConfigDir, u'product.locks')))
	
	
	
	#needed for configStates
	updatedConfigs = []
	
	logger.notice(u"Updating depots ...")
	if not noDepotDir:
		for depotId in os.listdir(backupDepotConfigDir):
			oldPath = os.path.join(backupDepotConfigDir, depotId)
			oldDepot = os.path.join(oldPath, u'depot.ini')
			if (not oldDepot.endswith('.ini')) or (not os.path.isfile(oldDepot)):
				logger.debug2(u"Ignoring '%s'" % (oldPath))
				continue
			try:
				depotId = forceHostId(depotId)
			except Exception, e:
				logger.error(u"Invalid depot: '%s': %s" % (oldPath, e))
				continue
			
			logger.notice(u"Updating depot '%s'" % depotId)
			
			oldDepotDict = {
				'id':                  depotId,
				'opsiHostKey':         None,
				'depotLocalUrl':       None,
				'depotRemoteUrl':      None,
				'repositoryLocalUrl':  None,
				'repositoryRemoteUrl': None,
				'description':         None,
				'notes':               None,
				'hardwareAddress':     None,
				'ipAddress':           None,
				'inventoryNumber':     None,
				'networkAddress':      None,
				'maxBandwidth':        None,
				'isMasterDepot':       True
			}
			
			if depotId in opsiHostKeys.keys():
				oldDepotDict['opsiHostKey'] = opsiHostKeys[depotId]
			
			
			updatedProductPropertyStates = []
			try:
				iniFile = IniFile(filename = oldDepot)
				ini = iniFile.parse()
				
				if ini.has_option('depotshare', 'localurl'):
					oldDepotDict['depotLocalUrl']       = ini.get('depotshare', 'localurl')
				if ini.has_option('depotshare', 'remoteurl'):
					oldDepotDict['depotRemoteUrl']      = ini.get('depotshare', 'remoteurl')
				if ini.has_option('repository', 'localurl'):
					oldDepotDict['repositoryLocalUrl']  = ini.get('repository', 'localurl').replace(u'/products', u'/repository')
				if ini.has_option('repository', 'remoteurl'):
					oldDepotDict['repositoryRemoteUrl'] = ini.get('repository', 'remoteurl').replace(u'/products', u'/repository')
				if ini.has_option('repository', 'maxbandwidth'):
					oldDepotDict['maxBandwidth']        = ini.get('repository', 'maxbandwidth')
				if ini.has_option('depotserver', 'description'):
					oldDepotDict['description']         = ini.get('depotserver', 'description')
				if ini.has_option('depotserver', 'notes'):
					oldDepotDict['notes']               = ini.get('depotserver', 'notes')
				if ini.has_option('depotserver', 'network'):
					oldDepotDict['networkAddress']      = ini.get('depotserver', 'network')
				if ini.has_option('depotserver', 'hardwareaddress'):
					oldDepotDict['hardwareAddress']     = ini.get('depotserver', 'hardwareaddress')
				if ini.has_option('depotserver', 'ipaddress'):
					oldDepotDict['ipAddress']           = ini.get('depotserver', 'ipaddress')
				if ini.has_option('depotserver', 'inventorynumber'):
					oldDepotDict['inventoryNumber']     = ini.get('depotserver', 'inventorynumber')
				
			except Exception, e:
				logger.warning(u"Could not get all information on depot: %s" % (e))
			
			backend.host_createObjects([OpsiDepotserver.fromHash(oldDepotDict)])
			
			
			
			logger.notice(u"Updating products on depot '%s'" % (depotId))
			productFilenames = []
			
			for productPath in (os.path.join(oldPath, u'products', u'localboot'), os.path.join(oldPath, u'products', u'netboot')):
				if not os.path.isdir(productPath):
					logger.warning(u"Path does not exist, skipping: '%s'" % (productPath))
					continue
				
				for productId in os.listdir(productPath):
					try:
						productFilename = os.path.join(productPath, forceProductId(productId))
						if not (os.path.isfile(productFilename)):
							logger.debug2(u"Ignoring '%s'" % (productFilename))
							continue
						productFilenames.append(productFilename)
					except Exception, e:
						logger.warning(u"Invalid product: '%s' in '%s': %s" % (productId, productPath, e))
						continue
			
			
			
			updatedProductDependencies = []
			for productFilename in productFilenames:
				packageControlFile = PackageControlFile(filename = productFilename)
				oldProduct = None
				
				try:
					oldProduct = packageControlFile.getProduct()
				except Exception, e:
					logger.error(u"Invalid product '%s': %s" % (productFilename, e))
					continue
				
				backend.product_createObjects([oldProduct])
				
				
				
				logger.info(u"Updating ProductProperties in '%s'" % (oldProduct.getId()))
				for pp in packageControlFile.getProductProperties():
					try:
						pp.setPropertyId(pp.getPropertyId().replace(u' ', u'_'))
						if pp.getPossibleValues():
							pp.setEditable(False)
						backend.productProperty_createObjects([pp])
					except Exception, e:
						logger.error(u"Could not create ProductProperty '%s': %s" % (pp.getIdent(), e))
					
					updatedProductPropertyStates.append(
						ProductPropertyState.fromHash(
							{
							'productId':  pp.getProductId(),
							'propertyId': pp.getPropertyId().replace(u' ', u'_'),
							'objectId':   depotId,
							'values':     pp.getDefaultValues()
							}
						)
					)
				
				
				#logger.notice(u"Updating ProductDependencies in '%s'" % (depotId))
				#will be updated after all products
				#updatedProductDependencies = []
				for pd in packageControlFile.getProductDependencies():
					updatedProductDependencies.append(pd)
				
				logger.info(u"Updating ProductOnDepot on '%s'" % (depotId))
				
				locked = None
				if (len(lockedList) > 0):
					try:
						key = u'%s' % (oldProduct.getId().lower() + '#' + depotId.lower())
						locked = lockedList[key]
					except:
						pass
				
				backend.productOnDepot_createObjects([
						ProductOnDepot.fromHash({
							'productId':      oldProduct.getId(),
							'productType':    oldProduct.getType(),
							'productVersion': oldProduct.getProductVersion(),
							'packageVersion': oldProduct.getPackageVersion(),
							'depotId':        depotId,
							'locked':         locked
						})
				])
			
			logger.notice(u"Updating ProductDependencies on '%s'" % (depotId))
			for pd in updatedProductDependencies:
				try:
					backend.productDependency_createObjects([pd])
				except Exception, e:
					logger.error(u"Could not create ProductDependency '%s': %s" % (pd.getIdent(), e))
			
			
			
			logger.notice(u"Updating ProductPropertyStates in '%s'" % (depotId))
			for pps in updatedProductPropertyStates:
				try:
					backend.productPropertyState_createObjects([pps])
				except Exception, e:
					logger.error(u"Could not create ProductPropertyState '%s': %s" % (pps.getIdent(), e))
	else:
		logger.info(u"No depot folder, skipping depots.")
	
	logger.notice(u"Updating Configs ..." % ())
	try:
		iniFile = IniFile(filename = os.path.join(backupDir, u'global.ini'), ignoreCase = False)
		ini = iniFile.parse()
		
		for section in ini.sections():
			if section.lower() not in (u'networkconfig', u'generalconfig'):
				logger.warning(u"Unknown section in global.ini: %s" % (section))
				continue
			
			configId = None
			value = None
			
			for option in ini.options(section):
				configId = configId = option.lower()
				value = ini.get(section, option)
				
				multiValue = False
				try:
					if (section.lower() == u'networkconfig'):
						if (option.lower() == u'depotid'):
							configId = u'clientconfig.depot.id'
						elif (option.lower() == u'depotdrive'):
							configId = u'clientconfig.depot.drive'
						elif (option.lower() == u'nextbootserviceurl'):
							configId = u'clientconfig.configserver.url'
							if (value.find('/rpc') == -1):
								value = value + '/rpc'
							multiValue = True
						elif (option.lower() == u'windomain'):
							configId = u'clientconfig.windows.domain'
				except Exception, e:
					logger.error(u"Error in option '%s' in section '%s': '%s'" % (option, section, e))
					continue
				
				updatedConfigs.append(UnicodeConfig(id = configId, defaultValues = [value], multiValue = multiValue))
	except Exception, e:
		logger.error(u"Failed to update config '%s': '%s'" % (os.path.join(backupDir, u'global.ini'), e))
	
	for c in updatedConfigs:
		try:
			backend.config_createObjects([c])
		except Exception, e:
			logger.error(u"Could not create config '%s': %s" % (c.getIdent(), e))
	
	
	logger.notice(u"Updating clients ...")
	if not noClientDir:
		for filename in os.listdir(backupClientConfigDir):
			updatedConfigStates = []
			
			oldClient = os.path.join(backupClientConfigDir, filename)
			if not (filename.endswith('.ini')) or not os.path.isfile(oldClient):
				logger.debug2(u"Ignoring client ini '%s'" % (filename))
				continue
			try:
				clientId = forceHostId(filename[:-4].replace('_', '-'))
			except Exception, e:
				logger.error(u"Invalid client id '%s': %s" % (filename[:-4], e))
				continue
			
			logger.notice(u"Updating client '%s'" % clientId)
			
			oldClientDict = {
				'id':              clientId,
				'opsiHostKey':     None,
				'description':     None,
				'notes':           None,
				'hardwareAddress': None,
				'ipAddress':       None,
				'inventoryNumber': None,
				'created':         None,
				'lastSeen':        None
			}
			
			if clientId in opsiHostKeys.keys():
				oldClientDict['opsiHostKey'] = opsiHostKeys[clientId]
			
			
			updatedProductPropertyStates = []
			updatedProductOnClients = []
			try:
				iniFile = IniFile(filename = oldClient)
				ini = iniFile.parse()
				
				if ini.has_option('info', 'description'):
					oldClientDict['description']     = ini.get('info', 'description')
				if ini.has_option('info', 'notes'):
					oldClientDict['notes']           = ini.get('info', 'notes')
				if ini.has_option('info', 'macaddress'):
					oldClientDict['hardwareAddress'] = ini.get('info', 'macaddress')
				if ini.has_option('info', 'ipaddress'):
					oldClientDict['ipAddress']       = ini.get('info', 'ipaddress')
				if ini.has_option('info', 'inventorynumber'):
					oldClientDict['inventoryNumber'] = ini.get('info', 'inventorynumber')
				if ini.has_option('info', 'created'):
					oldClientDict['created']         = ini.get('info', 'created')
				if ini.has_option('info', 'lastSeen'):
					oldClientDict['lastSeen']        = ini.get('info', 'lastSeen')
				
				for section in ini.sections():
					if (section.lower().endswith(u'-install')):
						for option in ini.options(section):
							try:
								updatedProductPropertyStates.append(
									ProductPropertyState.fromHash(
										{
										'productId':  section[:-8],
										'propertyId': option,
										'objectId':   clientId,
										'values':     [ini.get(section, option)]
										}
										)
									)
							except Exception, e:
								logger.error(u"Exception while creating ProductPropertyState from '%s': %s" % (section, e))
					
					elif (section.lower().endswith(u'_product_states')):
						for productId in ini.options(section):
							try:
								poc = {
									'productId':           productId,
									'productType':         section[:-15],
									'clientId':            clientId,
									'installationStatus':  u'not_installed',
									'actionRequest':       u'none',
									'actionProgress':      None,
									'targetConfiguration': None,
									'productVersion':      None,
									'packageVersion':      None,
									'modificationTime':    None
								}
								
								try:
									(poc['installationStatus'], poc['actionRequest']) = ini.get(section, productId).split(u':')
								except Exception, e:
									logger.error(u"Failed to get state from '%s': %s" % (ini.get(section, productId), e))
								
								if poc['installationStatus'] not in (u'installed', u'not_installed'):
									poc['actionProgress'] = poc['installationStatus']
									poc['installationStatus'] = u'not_installed'
								
								if not poc['actionRequest'] in (u'setup', u'uninstall', u'update', u'always', u'once', u'custom', u'none'):
									poc['actionRequest'] = u'none'
								
								if (poc['installationStatus'] == 'not_installed') and (poc['actionRequest'] == 'none'):
									continue
								
								if ini.has_section(productId + u'-state'):
									if (ini.get(productId + u'-state', 'productversion') != u''):
										poc['productVersion']   = ini.get(productId + u'-state', 'productversion')
									if (ini.get(productId + u'-state', 'packageversion') != u''):
										poc['packageVersion']   = ini.get(productId + u'-state', 'packageversion')
									if ini.has_option(productId + u'-state', 'laststatechange'):
										poc['modificationTime'] = ini.get(productId + u'-state', 'laststatechange')
								
								updatedProductOnClients.append(ProductOnClient.fromHash(poc))
							except Exception, e:
								logger.error(u"Exception while creating ProductOnClient from '%s': %s" % (oldClient, e))
					
#					elif (section.lower().endswith(u'-state')):
#						continue #will be handled above
					
					elif (section.lower() in (u'networkconfig', u'generalconfig')):
						for option in ini.options(section):
							configId = configId = option.lower()
							value = ini.get(section, option)
							
							try:
								if (section.lower() == u'networkconfig'):
									if (option.lower() == u'depotid'):
										configId = u'clientconfig.depot.id'
									elif (option.lower() == u'depotdrive'):
										configId = u'clientconfig.depot.drive'
									elif (option.lower() == u'nextbootserviceurl'):
										configId = u'clientconfig.configserver.url'
										if (value.find('/rpc') == -1):
											value = value + '/rpc'
									elif (option.lower() == u'windomain'):
										configId = u'clientconfig.windows.domain'
							except Exception, e:
								logger.error(u"%s" % (e))
								continue
							
							updatedConfigStates.append(ConfigState(configId = configId, objectId = clientId, values = [value]))
				
			except Exception, e:
				logger.warning(u"Could not get all information on client: %s" % e)
			
			backend.host_createObjects([OpsiClient.fromHash(oldClientDict)])
			
			for cs in updatedConfigStates:
				#TODO: check, if configState.configId exists
				try:
					backend.configState_createObjects([cs])
				except Exception, e:
					logger.error(u"Could not create configState '%s': %s" % (cs.getIdent(), e))
			
			logger.info(u"Updating ProductOnClients in '%s'" % (clientId))
			for poc in updatedProductOnClients:
				try:
					backend.productOnClient_createObjects([poc])
				except Exception, e:
					logger.error(u"Could not create ProductOnClient '%s': %s" % (poc.getIdent(), e))
			
			
			logger.info(u"Updating ProductPropertyStates in '%s'" % (clientId))
			for pps in updatedProductPropertyStates:
				try:
					backend.productPropertyState_createObjects([pps])
				except Exception, e:
					logger.error(u"Could not create ProductPropertyState '%s': %s" % (pps.getIdent(), e))
	else:
		logger.error(u"No client folder, skipping clients.")
	
	
	
	logger.notice(u"Updating Groups ..." % ())
	updatedGroups = []
	updatedObjectToGroups = []
	backupClientGroupsFile = os.path.join(backupDir, u'clientgroups.ini')
	if os.path.isfile(backupClientGroupsFile):
		iniFile = IniFile(filename = backupClientGroupsFile)
		ini = iniFile.parse()
		
		parentGroupIdList= []
		for section in ini.sections():
			try:
				g = {
					'id':            forceGroupId(section),
					'description':   None,
					'notes':         None,
					'parentGroupId': None
				}
				
				for option in ini.options(section):
					if (option.lower() == u'parentgroupid'):
						updatedGroup['parentGroupId'] = ini.get(section, option)
						if (not ini.get(section, option) in parentGroupIdList):
							parentGroupIdList.append(ini.get(section, option))
						continue
					
					if (ini.get(section, option) == 0):
						logger.debug2(u"Ignoring objectId '%s' in '%s' (value is 0)" % (option, section))
						continue
					
					otg = {
						'groupId'   : section,
						'groupType' : 'HostGroup',
						'objectId'  : forceObjectId(option)
					}
					
					updatedObjectToGroups.append(ObjectToGroup.fromHash(otg))
				
				updatedGroups.append(HostGroup.fromHash(g))
			except Exception, e:
				logger.error(u"Exception while creating Group from '%s': %s" % (section, e))
		
		#switching groups with parentGroupId after parentGroup
		switchedGroups = []
		unsortedGroups = updatedGroups
		counter = -1
		while (len(switchedGroups) != len(updatedGroups)):
			if (counter > 1000): #TODO: check for unresolved parentGroupIds
				logger.error(u"Unresolved parentGroupIdList: %s" % (parentGroupIdList))
				break
			else:
				counter =+ 1
			
			nowUnsorted = []
			for ug in unsortedGroups:
				if (ug.getParentGroupId() is None) or (not ug.getParentGroupId() in parentGroupIdList):
					switchedGroups.append(ug)
					if (ug.getId() in parentGroupIdList):
						parentGroupIdList.remove(ug.getId())
				else:
					nowUnsorted.append(ug)
			
			unsortedGroups = nowUnsorted
		
		updatedGroups = switchedGroups
		
		
		for g in updatedGroups:
			try:
				backend.group_createObjects([g])
			except Exception, e:
				logger.error(u"Could not create Group '%s': %s" % (g.getIdent(), e))
		
		for otg in updatedObjectToGroups:
			try:
				backend.objectToGroup_createObjects([otg])
			except Exception, e:
				logger.error(u"Could not create ObjectToGroup '%s': %s" % (otg.getIdent(), e))
	else:
		logger.error(u"No groups file, skipping groups.")
	
	
	
	#TODO: ignore?
	#AuditSoftwares/AuditSoftwareOnClients/AuditHardwares/AuditHardwareOnHosts



def configureMySQLBackend():
	backendConfigFile = u'/etc/opsi/backends/mysql.conf'
	
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	logger.info(u"Loading backend config '%s'" % backendConfigFile)
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	logger.info(u"Current mysql backend config: %s" % config)
	
	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type = 'snack')
	try:
		dbAdminUser = u'root'
		dbAdminPass = u''
		messageBox = None
		while True:
			values = [
				{ "name": u"Database host",             "value": config['address'] },
				{ "name": u"Database admin user",       "value": dbAdminUser },
				{ "name": u"Database admin password",   "value": dbAdminPass, "password": True },
				{ "name": u"Opsi database name",        "value": config['database'] },
				{ "name": u"Opsi database user",        "value": config['username'] },
				{ "name": u"Opsi database password",    "value": config['password'], "password": True }
			]
			values = ui.getValues(title = u'MysQL config', width = 70, height = 15, entries = values)
			if values is None:
				raise Exception(u"Canceled")
			
			config['address']  = values[0]["value"]
			dbAdminUser        = values[1]["value"]
			dbAdminPass        = values[2]["value"]
			config['database'] = values[3]["value"]
			config['username'] = values[4]["value"]
			config['password'] = values[5]["value"]
			
			messageBox = ui.createMessageBox(width = 70, height = 20, title = u'MysQL config', text = u'')
			# Connect to database host
			logger.notice(u"Connecting to host '%s' as user '%s'" % (config['address'], dbAdminUser))
			messageBox.addText(u"Connecting to host '%s' as user '%s'\n" % (config['address'], dbAdminUser))
			
			try:
				db = MySQLdb.connect(host = config['address'], user = dbAdminUser, passwd = dbAdminPass)
			except Exception, e:
				messageBox.hide()
				logger.error(u"Failed to connect to host '%s' as user '%s': %s" % (config['address'], dbAdminUser, e))
				ui.showError(text = u"Failed to connect to host '%s' as user '%s': %s" % (config['address'], dbAdminUser, e),
						title = u'Failed to connect', width = 70, height = 6, seconds = 0)
				continue
			logger.notice(u"Successfully connected to host '%s' as user '%s'" % (config['address'], dbAdminUser))
			messageBox.addText(u"Successfully connected to host '%s' as user '%s'\n" % (config['address'], dbAdminUser))
			
			# Create opsi database and user
			logger.notice(u"Creating database '%s'" % config['database'])
			messageBox.addText(u"Creating database '%s'\n" % config['database'])
			try:
				db.query(u'CREATE DATABASE %s DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_bin;' % config['database'])
			except MySQLdb.ProgrammingError, e:
				if (e[0] != 1007):
					# 1007: database exists
					raise
			logger.notice(u"Database '%s' created" % config['database'])
			messageBox.addText(u"Database '%s' created\n" % config['database'])
			
			def createUser(host):
				logger.notice(u"Creating user '%s' and granting all rights on '%s'" % (config['username'], config['database']))
				messageBox.addText(u"Creating user '%s' and granting all rights on '%s'\n" % (config['username'], config['database']))
				db.query(u'USE %s;' % config['database'])
				db.query(u'GRANT ALL ON %s .* TO %s@%s IDENTIFIED BY \'%s\'' \
					% (config['database'], config['username'], host, config['password']));
				db.query(u'FLUSH PRIVILEGES;')
				logger.notice(u"User '%s' created and privileges set" % config['username'])
				messageBox.addText(u"User '%s' created and privileges set\n" % config['username'])
			
			sysconf = getSysConfig()
			if config['address'] in ("localhost", "127.0.0.1", sysconf['hostname'], sysconf['fqdn']):
				createUser("localhost")
				if config['address'] not in ("localhost", "127.0.0.1"):
					createUser(config['address'])
			else:
				createUser(sysConfig['ipAddress'])
				createUser(sysConfig['fqdn'])
				createUser(sysConfig['hostname'])
			
			# Disconnect from database
			db.close()
			
			# Test connection / credentials
			logger.notice(u"Testing connection to database '%s' as user '%s'" % (config['database'], config['username']))
			messageBox.addText(u"Testing connection to database '%s' as user '%s'\n" % (config['database'], config['username']))
			
			try:
				db = MySQLdb.connect(host = config['address'], user = config['username'], passwd = config['password'], db = config['database'])
				db.close()
			except Exception, e:
				messageBox.hide()
				logger.error(u"Failed to connect to host '%s' as user '%s': %s" % (config['address'], config['username'], e))
				ui.showError(text = u"Failed to connect to host '%s' as user '%s': %s" % (config['address'], config['username'], e),
						title = u'Connection failed', width = 70, height = 6, seconds = 0)
				continue
			
			logger.notice(u"Successfully connected to host '%s' as user '%s'" % (config['address'], config['username']))
			messageBox.addText(u"Successfully connected to host '%s' as user '%s'\n" % (config['address'], config['username']))
			break
		
		logger.notice(u"Updating backend config '%s'" % backendConfigFile)
		messageBox.addText(u"Updating backend config '%s'\n" % backendConfigFile)
		
		lines = []
		f = codecs.open(backendConfigFile, 'r', 'utf-8')
		for line in f.readlines():
			if re.search('^\s*config\s*\=', line):
				break
			lines.append(line)
		f.close()
		f = codecs.open(backendConfigFile, 'w', 'utf-8')
		f.writelines(lines)
		f.write("config = %s\n" % objectToBeautifiedText(config))
		f.close()
		
		logger.notice(u"Backend config '%s' updated" % backendConfigFile)
		messageBox.addText(u"Backend config '%s' updated\n" % backendConfigFile)
		
		logger.notice(u"Initializing mysql backend")
		messageBox.addText(u"Initializing mysql backend\n")
		
		backend = MySQLBackend(**config)
		backend.backend_createBase()
		
		time.sleep(2)
		messageBox.hide()
		
		ui.showMessage(title = u'Success', text = u"MySQL Backend configuration done", width = 70, height = 4, seconds = 0)
		
	finally:
		ui.exit()
		logger.setConsoleLevel(consoleLevel)
	

def registerDepot(username = None, password = None, configserver = None):
	backendConfigFile = u'/etc/opsi/backends/jsonrpc.conf'
	dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf'
	
	getSysConfig()
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	logger.info(u"Loading backend config '%s'" % backendConfigFile)
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	logger.info(u"Current jsonrpc backend config: %s" % config)
	
	
	jsonrpcBackend = None
	depot = None
	
	if username and password and configserver:
		logger.notice(u"Credentials are given, trying to registering depot noninteractive.")
		config['address'] = configserver
		adminUser = username
		adminPass = password
		
		try:
			jsonrpcBackend = JSONRPCBackend(address = config['address'], username = adminUser, password = adminPass)
			if not jsonrpcBackend.accessControl_userIsAdmin():
				raise Exception(u"User '%s' is not an admin user" % adminUser)
		except Exception, e:
			logger.error(u"Failed to connect to config server '%s' as user '%s': %s" % (config['address'], adminUser, e))
		logger.notice(u"Successfully connected to config server '%s' as user '%s'" % (config['address'], adminUser))
		
		depots = jsonrpcBackend.host_getObjects(id = getSysConfig()['fqdn'])
		if depots:
			# Already exists
			depot = depots[0]
			if not depot.depotWebdavUrl:  depot.depotWebdavUrl = u''
			if not depot.masterDepotId:   depot.masterDepotId = u''
			if not depot.hardwareAddress: depot.hardwareAddress = getSysConfig()['hardwareAddress'] or u''
			if not depot.ipAddress:       depot.ipAddress = getSysConfig()['ipAddress'] or u''
			if not depot.networkAddress:  depot.ipAddress = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask'])
			if not depot.depotWebdavUrl:  depot.depotWebdavUrl = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn']
			if not depot.masterDepotId:   depot.masterDepotId = None
		else:
			#depotLocalUrl  = u'file:///opt/pcbin/install'
			#depotRemoteUrl = u'smb://%s/opt_pcbin/install' % getSysConfig()['hostname']
			#if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']
			
			depot = OpsiDepotserver(
					id                  = getSysConfig()['fqdn'],
					opsiHostKey         = None,
					depotLocalUrl       = depotLocalUrl,
					depotRemoteUrl      = depotRemoteUrl,
					depotWebdavUrl      = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
					repositoryLocalUrl  = u'file:///var/lib/opsi/repository',
					repositoryRemoteUrl = u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
					description         = u'',
					notes               = u'',
					hardwareAddress     = getSysConfig()['hardwareAddress'] or u'',
					ipAddress           = getSysConfig()['ipAddress'] or u'',
					inventoryNumber     = u'',
					networkAddress      = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
					maxBandwidth        = 0,
					isMasterDepot       = True,
					masterDepotId       = None,
			)
		
		
	else:
		consoleLevel = logger.getConsoleLevel()
		logger.setConsoleLevel(LOG_NONE)
		ui = UIFactory(type = 'snack')
		try:
			adminUser = u'root'
			adminPass = u''
			messageBox = None
			while True:
				values = [
					{ "name": u"Config server",             "value": config['address'] },
					{ "name": u"Opsi admin user",           "value": adminUser },
					{ "name": u"Opsi admin password",       "value": adminPass, "password": True }
				]
				values = ui.getValues(title = u'Config server connection', width = 70, height = 10, entries = values)
				if values is None:
					raise Exception(u"Canceled")
				
				config['address']  = values[0]["value"]
				adminUser          = values[1]["value"]
				adminPass          = values[2]["value"]
				
				messageBox = ui.createMessageBox(width = 70, height = 20, title = u'Register depot', text = u'')
				# Connect to config server
				logger.notice(u"Connecting to config server '%s' as user '%s'" % (config['address'], adminUser))
				messageBox.addText(u"Connecting to config server '%s' as user '%s'\n" % (config['address'], adminUser))
				
				try:
					jsonrpcBackend = JSONRPCBackend(address = config['address'], username = adminUser, password = adminPass)
					if not jsonrpcBackend.accessControl_userIsAdmin():
						raise Exception(u"User '%s' is not an admin user" % adminUser)
				except Exception, e:
					messageBox.hide()
					logger.error(u"Failed to connect to config server '%s' as user '%s': %s" % (config['address'], adminUser, e))
					ui.showError(text = u"Failed to connect to config server '%s' as user '%s': %s" % (config['address'], adminUser, e),
							title = u'Failed to connect', width = 70, height = 6, seconds = 0)
					continue
				logger.notice(u"Successfully connected to config server '%s' as user '%s'" % (config['address'], adminUser))
				messageBox.addText(u"Successfully connected to config server '%s' as user '%s'\n" % (config['address'], adminUser))
				break
			
			depots = jsonrpcBackend.host_getObjects(id = getSysConfig()['fqdn'])
			if depots:
				# Already exists
				depot = depots[0]
				if not depot.depotWebdavUrl:  depot.depotWebdavUrl = u''
				if not depot.masterDepotId:   depot.masterDepotId = u''
				if not depot.hardwareAddress: depot.hardwareAddress = getSysConfig()['hardwareAddress'] or u''
				if not depot.ipAddress:       depot.ipAddress = getSysConfig()['ipAddress'] or u''
				if not depot.networkAddress:  depot.ipAddress = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask'])
				if not depot.depotWebdavUrl:  depot.depotWebdavUrl = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn']
			else:
				#depotLocalUrl  = u'file:///opt/pcbin/install'
				#depotRemoteUrl = u'smb://%s/opt_pcbin/install' % getSysConfig()['hostname']
				#if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
				depotLocalUrl = u'file:///var/lib/opsi/depot'
				depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']
				
				depot = OpsiDepotserver(
						id                  = getSysConfig()['fqdn'],
						opsiHostKey         = None,
						depotLocalUrl       = depotLocalUrl,
						depotRemoteUrl      = depotRemoteUrl,
						depotWebdavUrl      = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
						repositoryLocalUrl  = u'file:///var/lib/opsi/repository',
						repositoryRemoteUrl = u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
						description         = u'',
						notes               = u'',
						hardwareAddress     = getSysConfig()['hardwareAddress'] or u'',
						ipAddress           = getSysConfig()['ipAddress'] or u'',
						inventoryNumber     = u'',
						networkAddress      = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
						maxBandwidth        = 0,
						isMasterDepot       = True,
						masterDepotId       = None,
				)
			while True:
				if (depot.maxBandwidth < 0):
					depot.maxBandwidth = 0
				if (depot.maxBandwidth > 0):
					depot.maxBandwidth = int(depot.maxBandwidth/1000)
				
				values = [
					{ "name": u"Description",                 "value": depot.description          },
					{ "name": u"Inventory number",            "value": depot.inventoryNumber      },
					{ "name": u"Notes",                       "value": depot.notes                },
					{ "name": u"Ip address",                  "value": depot.ipAddress            },
					{ "name": u"Hardware address",            "value": depot.hardwareAddress      },
					{ "name": u"Network address",             "value": depot.networkAddress       },
					{ "name": u"Maximum bandwidth (kbyte/s)", "value": depot.maxBandwidth         },
					{ "name": u"Local depot url",             "value": depot.depotLocalUrl        },
					{ "name": u"Remote depot url",            "value": depot.depotRemoteUrl       },
					{ "name": u"Depot webdav url",            "value": depot.depotWebdavUrl       },
					{ "name": u"Local repository url",        "value": depot.repositoryLocalUrl   },
					{ "name": u"Remote repository url",       "value": depot.repositoryRemoteUrl  },
					{ "name": u"Is master depot",             "value": depot.isMasterDepot        },
					{ "name": u"Master depot id",             "value": depot.masterDepotId or u'' },
					
				]
				values = ui.getValues(title = u'Depot server settings', width = 70, height = 16, entries = values)
				if values is None:
					raise Exception(u"Canceled")
				
				error = None
				try:
					depot.setDescription( values[0].get('value') )
				except Exception, e:
					if not error: error = u'Invalid description'
				
				try:
					depot.setInventoryNumber( values[1].get('value') )
				except Exception, e:
					if not error: error = u'Inventory number invalid'
				
				try:
					depot.setNotes( values[2].get('value') )
				except Exception, e:
					if not error: error = u'Invalid notes'
				
				try:
					depot.setIpAddress( values[3].get('value') )
				except Exception, e:
					if not error: error = u'Invalid ip address'
				
				try:
					depot.setHardwareAddress( values[4].get('value') )
				except Exception, e:
					if not error: error = u'Invalid hardware address'
				
				try:
					depot.setNetworkAddress( values[5].get('value') )
				except Exception, e:
					if not error: error = u'Invalid network address'
				
				try:
					depot.setMaxBandwidth( forceInt(values[6].get('value'))*1000 )
				except Exception, e:
					if not error: error = u'Invalid maximum bandwidth'
				
				try:
					depot.setDepotLocalUrl( values[7].get('value') )
				except Exception, e:
					if not error: error = u'Depot local url invalid'
				
				try:
					depot.setDepotRemoteUrl( values[8].get('value') )
				except Exception, e:
					if not error: error = u'Depot remote url invalid'
				
				try:
					if values[9].get('value'):
						depot.setDepotWebdavUrl( values[9].get('value') )
					else:
						depot.depotWebdavUrl = None
				except Exception, e:
					if not error: error = u'Depot webdav url invalid'
				
				try:
					depot.setRepositoryLocalUrl( values[10].get('value') )
				except Exception, e:
					if not error: error = u'Repository local url invalid'
				
				try:
					depot.setRepositoryRemoteUrl( values[11].get('value') )
				except Exception, e:
					if not error: error = u'Repository remote url invalid'
				
				try:
					depot.setIsMasterDepot( values[12].get('value') )
				except Exception, e:
					if not error: error = u'Invalid value for is master depot'
				
				try:
					if values[13].get('value'):
						depot.setMasterDepotId( values[13].get('value') )
					else:
						depot.masterDepotId = None
				except Exception, e:
					if not error: error = u'Master depot id invalid'
				
				if error:
					ui.showError(title = u'Bad value', text = error, width = 50, height = 5)
					continue
				
				break
		finally:
			ui.exit()
			logger.setConsoleLevel(consoleLevel)
	
	logger.notice(u"Creating depot '%s'" % depot.id)
	jsonrpcBackend.host_createObjects([ depot ])
	
	logger.notice(u"Getting depot '%s'" % depot.id)
	depots = jsonrpcBackend.host_getObjects(id = depot.id)
	if not depots:
		raise Exception(u"Failed to create depot")
	depot = depots[0]
	config['username'] = depot.id
	config['password'] = depot.opsiHostKey
	jsonrpcBackend.backend_exit()
	
	logger.notice(u"Testing connection to config server as user '%s'" % config['username'])
	try:
		jsonrpcBackend = JSONRPCBackend(address = config['address'], username = config['username'], password = config['password'])
	except Exception, e:
		raise Exception(u"Failed to connect to config server as user '%s': %s" % (config['username'], e))
	logger.notice(u"Successfully connected to config server as user '%s'" % config['username'])
	
	logger.notice(u"Updating backend config '%s'" % backendConfigFile)
	lines = []
	f = codecs.open(backendConfigFile, 'r', 'utf-8')
	for line in f.readlines():
		if re.search('^\s*config\s*\=', line):
			break
		lines.append(line)
	f.close()
	f = codecs.open(backendConfigFile, 'w', 'utf-8')
	f.writelines(lines)
	f.write("config = %s\n" % forceUnicode(config).replace(',', ',\n').replace('{', '{\n').replace('}', '\n}'))
	f.close()
	logger.notice(u"Backend config '%s' updated" % backendConfigFile)
	
	logger.notice(u"Updating dispatch config '%s'" % dispatchConfigFile)
	lines = []
	f = codecs.open(dispatchConfigFile, 'r', 'utf-8')
	for line in f.readlines():
		if line.strip() and line.strip()[0] not in (';', '#'):
			break
		lines.append(line)
	f.close()
	f = codecs.open(dispatchConfigFile, 'w', 'utf-8')
	f.writelines(lines)
	f.write("backend_.* : jsonrpc, opsipxeconfd, dhcpd\n")
	f.write(".*         : jsonrpc\n")
	f.close()
	logger.notice(u"Dispatch config '%s' updated" % dispatchConfigFile)
	
	setRights()
	
	logger.notice(u"Restarting services")
	execute("/etc/init.d/opsiconfd restart")
	execute("/etc/init.d/opsipxeconfd restart")
	
def renewOpsiconfdCert():
	
	OPSICONFD_CERTFILE = u"/etc/opsi/opsiconfd.pem"
	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type = 'snack')
	try:
		which("ucr")
		logger.notice(u"Don't use recreate method on UCS-Systems")
		return
	except:
		pass
	
	try:
		#loaddefaults
		certparams = {
			"country"            	: u"DE",
       			"state"              	: u"RP",
       			"locality"           	: u"Mainz",
       			"organization"         	: u"uib gmbh",
       			"organizationalUnit" 	: u"",
       			"commonName"      	: forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF)),
       			"emailAddress"       	: u"",
       			"expires"                	: u"2",
       		}
       		
		country            		= ""
		state             			= ""
		locality          			= ""
		organization       		= ""
		organizationalUnit		= ""
		commonName      		= None
		emailAddress       		= ""
		key					= None
       		
       		if os.path.exists(OPSICONFD_CERTFILE):
       			data = open(OPSICONFD_CERTFILE).read()
       			cert = crypto.load_certificate(crypto.FILETYPE_PEM, data)
       			key  = crypto.load_privatekey(crypto.FILETYPE_PEM, data)

       			certparams["country"]            = cert.get_subject().C
       			certparams["state"]              = cert.get_subject().ST
       			certparams["locality"]           = cert.get_subject().L
       			certparams["organization"]       = cert.get_subject().O
       			certparams["organizationalUnit"] = cert.get_subject().OU
       			certparams["commonName"]         = cert.get_subject().CN
       			certparams["emailAddress"]       = cert.get_subject().emailAddress
		
		
		messageBox = None
		while True:
			values = [
				{ "name": u"Country",          		"value": certparams["country"] },
                        	{ "name": u"State",            		"value": certparams["state"] },
                        	{ "name": u"Locality",         		"value": certparams["locality"] },
                        	{ "name": u"Organization",     		"value": certparams["organization"] },
                        	{ "name": u"OrganizationUnit",	"value": certparams["organizationalUnit"] },
                        	{ "name": u"hostname",         		"value": certparams["commonName"] },
                        	{ "name": u"Emailaddress",     	"value": certparams["emailAddress"] },
                        	{ "name": u"Expires (Years)",  		"value": certparams["expires"] },
			]
			values = ui.getValues(title = u'Renew opsiconfd Certificate', width = 70, height = 15, entries = values)
			
			if values is None:
				raise Exception(u"Canceled")
			
			error = None
			
			country            	= values[0]["value"]
                	state              		= values[1]["value"]
                	locality           		= values[2]["value"]
                	organization       	= values[3]["value"]
                	organizationalUnit	= values[4]["value"]
                	commonName      	= values[5]["value"]
                	emailAddress       	= values[6]["value"]
                	
			
			if not commonName == forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF)):
				if not error: error = "commonName must be the FQDN from Server"
			
			try:
				expires  = forceInt(values[7]["value"])
			except Exception, e:
					if not error: error = u'No valid years for expiredate given, must be an integer'
				
			if error:
				ui.showError(title = u'Bad value', text = error, width = 50, height = 5)
				continue
				
			break
			
	except Exception, e:
		if ui:
			ui.exit()
		logger.setConsoleLevel(consoleLevel)
		logger.error(e)
		return
	finally:
		if ui:
			ui.exit()
		logger.setConsoleLevel(consoleLevel)
			
	
	logger.notice(u"Creating new opsiconfd cert")
	logger.notice(u"Generating new key pair")
	if key:
		k = key
	else:
		k = crypto.PKey()
		k.generate_key(crypto.TYPE_RSA, 1024)
	
	logger.notice(u"Generating new self-signed cert")
	cert = crypto.X509()
	cert.get_subject().C = country
	cert.get_subject().ST = state
	cert.get_subject().L = locality
	cert.get_subject().O = organization
	cert.get_subject().OU = organizationalUnit
	cert.get_subject().CN = commonName
	cert.get_subject().emailAddress = emailAddress
	
	logger.notice(u"Generating new Serialnumber")
	#Todo generating Serial new
	cert.set_serial_number(1000)
	logger.notice(u"Setting new expiration date (%d years)" % expires)
	cert.gmtime_adj_notBefore(0)
	cert.gmtime_adj_notAfter(expires*365*24*60*60)
	
	logger.notice(u"Filling certificate with new data")
	cert.set_issuer(cert.get_subject())
	cert.set_pubkey(k)
	cert.set_version(2)
        
	logger.notice(u"Signing Certificate")
	cert.sign(k, 'sha1')
	backupfile = ''.join((OPSICONFD_CERTFILE, ".bak"))
	logger.notice(u"Backup existing Certifcate to %s" % backupfile)
	shutil.copy(OPSICONFD_CERTFILE, backupfile)
	
	logger.notice(u"Overwriting existing Certificate")
	certcontext = "".join((
		crypto.dump_certificate(crypto.FILETYPE_PEM, cert),
		crypto.dump_privatekey(crypto.FILETYPE_PEM, k))
	)
     	open(OPSICONFD_CERTFILE, "wt").write(certcontext)
     	logger.notice(u"Generating and filling new randomize string")
     	open("/tmp/opsiconfd.rand", "wt").write(rand.bytes(512))
     	execute("%s gendh -rand %s 512 >> %s" % (
     		which("openssl"), "/tmp/opsiconfd.rand", OPSICONFD_CERTFILE))
     	logger.notice(u"Setting rights")
     	opsiconfdUid  = pwd.getpwnam(OPSICONFD_USER)[2]
	adminGroupGid = grp.getgrnam(ADMIN_GROUP)[2]
     	os.chown(u'/etc/opsi/passwd', opsiconfdUid, adminGroupGid)
     	os.chmod(u'/etc/opsi/passwd', 0660)
     	logger.notice(u"cleanup")
     	os.remove("/tmp/opsiconfd.rand")
     	logger.notice(u"Restarting opsi Webservice")
     	
     	logger.notice(u"Restarting services")
     	execute("/etc/init.d/opsiconfd restart")
     	execute("/etc/init.d/opsipxeconfd restart")
 
	
	
	
def initializeBackends():
	if not os.path.exists(u'/etc/opsi/passwd'):
		f = codecs.open(u'/etc/opsi/passwd', 'w', 'utf-8')
		f.close()
		opsiconfdUid  = pwd.getpwnam(OPSICONFD_USER)[2]
		adminGroupGid = grp.getgrnam(ADMIN_GROUP)[2]
		os.chown(u'/etc/opsi/passwd', opsiconfdUid, adminGroupGid)
		os.chmod(u'/etc/opsi/passwd', 0660)
		
	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir   = u'/etc/opsi/backends',
		extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
		depotbackend       = False
	)
	backend.backend_createBase()
	
	logger.notice(u"Try to find a Configserver.")
	configServer = backend.host_getObjects(type = 'OpsiConfigserver')
	if not configServer and not backend.host_getIdents(type = 'OpsiConfigserver', id = getSysConfig()['fqdn']):
		depot = backend.host_getObjects(type = 'OpsiDepotserver', id = getSysConfig()['fqdn'])
		if not depot:
			logger.notice(u"Creating config server '%s'" % getSysConfig()['fqdn'])
			#depotLocalUrl  = u'file:///opt/pcbin/install'
			#depotRemoteUrl = u'smb://%s/opt_pcbin/install' % getSysConfig()['hostname']
			#if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']
			
			backend.host_createOpsiConfigserver(
				id                  = getSysConfig()['fqdn'],
				opsiHostKey         = None,
				depotLocalUrl       = depotLocalUrl,
				depotRemoteUrl      = depotRemoteUrl,
				depotWebdavUrl      = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
				repositoryLocalUrl  = u'file:///var/lib/opsi/repository',
				repositoryRemoteUrl = u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
				description         = None,
				notes               = None,
				hardwareAddress     = getSysConfig()['hardwareAddress'],
				ipAddress           = getSysConfig()['ipAddress'],
				inventoryNumber     = None,
				networkAddress      = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
				maxBandwidth        = 0,
				isMasterDepot       = True,
				masterDepotId       = None,
			)
			configServer = backend.host_getObjects(type = 'OpsiConfigserver', id = getSysConfig()['fqdn'])
		else:
			logger.notice(u"Converting depot server '%s' to config server" % getSysConfig()['fqdn'])
			configServer = OpsiConfigserver.fromHash(depot[0].toHash())
			backend.host_createObjects(configServer)
	else:
		depot = backend.host_getObjects(type = 'OpsiDepotserver', id = getSysConfig()['fqdn'])	
		if not depot:
			logger.notice(u"Creating depot server '%s'" % getSysConfig()['fqdn'])
			#depotLocalUrl  = u'file:///opt/pcbin/install'
			#depotRemoteUrl = u'smb://%s/opt_pcbin/install' % getSysConfig()['hostname']
			#if (getSysConfig()['distribution'].lower().find('suse linux enterprise server') != -1):
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']
			
			depotServer = backend.host_createOpsiDepotserver(
				id                  = getSysConfig()['fqdn'],
				opsiHostKey         = None,
				depotLocalUrl       = depotLocalUrl,
				depotRemoteUrl      = depotRemoteUrl,
				depotWebdavUrl      = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
				repositoryLocalUrl  = u'file:///var/lib/opsi/repository',
				repositoryRemoteUrl = u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
				description         = None,
				notes               = None,
				hardwareAddress     = getSysConfig()['hardwareAddress'],
				ipAddress           = getSysConfig()['ipAddress'],
				inventoryNumber     = None,
				networkAddress      = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
				maxBandwidth        = 0,
				isMasterDepot       = True,
				masterDepotId       = None,
			)
	if configServer:
		if configServer[0].id == getSysConfig()['fqdn']:
			configServer = backend.host_getObjects(type = 'OpsiConfigserver')
			if not configServer:
				raise Exception(u"Config server '%s' not found" % getSysConfig()['fqdn'])
			configServer = configServer[0]
			if getSysConfig()['ipAddress']:
				configServer.setIpAddress(getSysConfig()['ipAddress'])
			if getSysConfig()['hardwareAddress']:
				configServer.setHardwareAddress(getSysConfig()['hardwareAddress'])
		
			#make sure the config server is present in all backends or we get reference error later on
			backend.host_insertObject(configServer)
	backend.backend_exit()
	initializeConfigs(configServer = configServer)
	
	link = '/var/lib/opsi/depot'
	source = '/opt/pcbin/install'
	if not os.path.exists(link) and os.path.exists(source):
		try:
			os.symlink(source, link)
		except Exception, e:
			logger.warning(u"Failed to create symlink '%s' pointing to '%s': %s" % (link, source, e))
	
def initializeConfigs(configServer = None):
	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir   = u'/etc/opsi/backends',
		extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
		depotbackend       = False
	)
	backend.backend_createBase()
	
	configs = []
	configIdents = backend.config_getIdents(returnType = 'unicode')
	if not 'clientconfig.configserver.url' in configIdents and configServer:
		configs.append(
			UnicodeConfig(
				id             = u'clientconfig.configserver.url',
				description    = u'URL(s) of opsi config service(s) to use',
				possibleValues = [ u'https://%s:4447/rpc' % configServer.getIpAddress() ],
				defaultValues  = [ u'https://%s:4447/rpc' % configServer.getIpAddress() ],
				editable       = True,
				multiValue     = True
			)
		)
	if not 'clientconfig.depot.id' in configIdents and configServer:
		configs.append(
			UnicodeConfig(
				id             = u'clientconfig.depot.id',
				description    = u'ID of the opsi depot to use',
				possibleValues = [ configServer.getId() ],
				defaultValues  = [ configServer.getId() ],
				editable       = True,
				multiValue     = False
			)
		)
	if not 'clientconfig.depot.dynamic' in configIdents:
		configs.append(
			BoolConfig(
				id             = u'clientconfig.depot.dynamic',
				description    = u'Use dynamic depot selection',
				defaultValues  = [ False ]
			)
		)
	if not 'clientconfig.depot.drive' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'clientconfig.depot.drive',
				description    = u'Drive letter for depot share',
				possibleValues = [ u'c:', u'd:', u'e:', u'f:', u'g:', u'h:', u'i:', u'j:', u'k:', u'l:', u'm:', u'n:', u'o:', u'p:', u'q:', u'r:', u's:', u't:', u'u:', u'v:', u'w:', u'x:', u'y:', u'z:' ],
				defaultValues  = [ u'p:' ],
				editable       = False,
				multiValue     = False
			)
		)
	if not 'clientconfig.depot.protocol' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'clientconfig.depot.protocol',
				description    = u'Protocol for file transfer',
				possibleValues = [ 'cifs', 'webdav' ],
				defaultValues  = [ 'cifs' ],
				editable       = False,
				multiValue     = False
			)
		)
	if not 'clientconfig.windows.domain' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'clientconfig.windows.domain',
				description    = u'Windows domain',
				possibleValues = [],
				defaultValues  = [ getSysConfig()['winDomain'] ],
				editable       = True,
				multiValue     = False
			)
		)
	if not 'opsi-linux-bootimage.append' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'opsi-linux-bootimage.append',
				description    = u'Extra options to append to kernel command line',
				possibleValues = [ u'acpi=off', u'irqpoll', u'noapic', 'pci=nomsi', 'vga=normal', 'reboot=b' ],
				defaultValues  = [ u'' ],
				editable       = True,
				multiValue     = True
			)
		)
	if not 'license-management.use' in configIdents:
		configs.append(
			BoolConfig(
				id             = u'license-management.use',
				description    = u'Activate license management',
				defaultValues  = [ False ]
			)
		)
	if not 'software-on-demand.active' in configIdents:
		configs.append(
			BoolConfig(
				id             = u'software-on-demand.active',
				description    = u'Activate software-on-demand',
				defaultValues  = [ False ]
			)
		)
	if not 'software-on-demand.show-details' in configIdents:
		configs.append(
			BoolConfig(
				id             = u'software-on-demand.show-details',
				description    = u'Show more details for software-on-demand',
				defaultValues  = [ False ]
			)
		)
	if not 'software-on-demand.product-group-ids' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'software-on-demand.product-group-ids',
				description    = u'Product group ids containing products which are allowed to be installed on demand',
				possibleValues = [ u'software-on-demand' ],
				defaultValues  = [ u'software-on-demand' ],
				editable       = True,
				multiValue     = True
			)
		)
	if not 'product_sort_algorithm' in configIdents:
		configs.append(
			UnicodeConfig(
				id             = u'product_sort_algorithm',
				description    = u'Product sorting algorithm',
				possibleValues = [ u'algorithm1', u'algorithm2' ],
				defaultValues  = [ u'algorithm1' ],
				editable       = False,
				multiValue     = False
			)
		)
	
	if configs:
		backend.config_createObjects(configs)
	backend.backend_exit()

def editConfigDefaults():
	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir   = u'/etc/opsi/backends',
		extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
		depotbackend       = False
	)
	configs = backend.config_getObjects()
	
	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type = 'snack')
	try:
		while True:
			entries = []
			maxConfigIdLen = 0
			for config in configs:
				if (len(config.id) > maxConfigIdLen):
					maxConfigIdLen = len(config.id)
			format = u"%-10s %-" + str(maxConfigIdLen) + "s = %s"
			for config in configs:
				type = '[unicode]'
				if (config.getType() == 'BoolConfig'):
					type = '[bool]'
				entries.append({ "id": config.id, "name": format % ( type, config.id, u', '.join(forceUnicodeList(config.defaultValues)) ) })
			
			selection = ui.getSelection(entries, radio = True, width=100, height=10, title=u'Please select config value to change', okLabel='OK', cancelLabel='Cancel')
			
			if not selection:
				return
			
			configId = None
			for entry in entries:
				if (selection[0] == entry['name']):
					configId = entry['id']
					break
			
			selectedConfig = -1
			for i in range(len(configs)):
				if (configs[i].id == configId):
					selectedConfig = i
					break
			
			addNewValue = False
			cancelLabel = u'Back'
			title = u'Edit default values for: %s' % configs[selectedConfig].id
			text = configs[selectedConfig].description or u''
			if configs[selectedConfig].possibleValues:
				entries = []
				for possibleValue in configs[selectedConfig].possibleValues:
					entries.append({'name': possibleValue, 'value': possibleValue, 'selected': possibleValue in configs[selectedConfig].defaultValues})
				radio = not configs[selectedConfig].multiValue
				if configs[selectedConfig].editable:
					entries.append({'name': '<other value>', 'value': '<other value>', 'selected': False})
				selection = ui.getSelection(entries, radio = radio, width = 65, height = 10, title = title, text = text, cancelLabel = cancelLabel)
				
				if selection is None:
					continue
				if "<other value>" in selection:
					addNewValue = True
				else:
					configs[selectedConfig].setDefaultValues(selection)
			else:
				addNewValue = True
			
			if addNewValue:
				default = u''
				if configs[selectedConfig].defaultValues:
					default = configs[selectedConfig].defaultValues[0]
				value = ui.getValue(width = 65, height = 13, title = title, default = default, password = False, text = text, cancelLabel = cancelLabel)
				if value is None:
					continue
				
				possibleValues = configs[selectedConfig].getPossibleValues()
				if not value in possibleValues:
					possibleValues.append(value)
					configs[selectedConfig].setPossibleValues(possibleValues)
				configs[selectedConfig].setDefaultValues(value)
			
			backend.config_updateObjects([configs[selectedConfig]])
	
	finally:
		ui.exit()
		logger.setConsoleLevel(consoleLevel)

def cleanupBackend():
	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir   = u'/etc/opsi/backends',
		extensionConfigDir = u'/etc/opsi/backendManager/extend.d',
		depotbackend       = False
	)
	
	logger.notice(u"Cleaning up groups")
	updatedGroups = []
	groupIds = []
	groups = backend.group_getObjects(type = 'HostGroup')
	for group in groups:
		groupIds.append(group.id)
	for group in groups:
		if group.getParentGroupId() and group.getParentGroupId() not in groupIds:
			logger.info(u"Removing parent group id '%s' from group '%s' because parent group does not exist" % (group.parentGroupId, group.id))
			group.parentGroupId = None
			updatedGroups.append(group)
	if updatedGroups:
		backend.group_createObjects(updatedGroups)
	
	logger.notice(u"Cleaning up products")
	productIds = []
	productIdents = []
	
	for productOnDepot in backend.productOnDepot_getObjects():
		productIdent = u"%s;%s;%s" % (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion)
		if not productIdent in productIdents:
			productIdents.append(productIdent)
	deleteProducts = []
	for product in backend.product_getObjects():
		if not product.getIdent(returnType = 'unicode') in productIdents:
			logger.info(u"Marking unreferenced product %s for deletion" % product)
			deleteProducts.append(product)
		else:
			if not product.id in productIds:
				productIds.append(product.id)
	if deleteProducts:
		backend.product_deleteObjects(deleteProducts)
	
	logger.notice(u"Cleaning up product on depots")
	productIdents = []
	depotIds = []
	for depot in backend.host_getObjects(type=["OpsiConfigserver","OpsiDepotserver"]):
		depotIds.append(depot.id)
	for product in backend.product_getObjects():
		if not product.getIdent(returnType = 'unicode') in productIdents:
			productIdents.append(product.getIdent(returnType = 'unicode'))
	deleteProductOnDepots = []
	for productOnDepot in backend.productOnDepot_getObjects():
		productIdent = u"%s;%s;%s" % (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion)
		if not productOnDepot.depotId in depotIds:
			logger.info(u"Marking product on depot %s for deletion, because opsiDepot-Server '%s' not found" % (productOnDepot, productOnDepot.depotId))
			deleteProductOnDepots.append(productOnDepot)
		elif not productIdent in productIdents:
			logger.info(u"Marking product on depot %s with missing product reference for deletion" % productOnDepot)
			deleteProductOnDepots.append(productOnDepot)
	if deleteProductOnDepots:
		backend.productOnDepot_deleteObjects(deleteProductOnDepots)
	
	logger.notice(u"Cleaning up product on clients")
	deleteProductOnClients = []
	clientIds = []
	for client in backend.host_getObjects(type=["OpsiClient"]):
		clientIds.append(client.id)
	for productOnClient in backend.productOnClient_getObjects():
		if productOnClient.clientId not in clientIds:
			logger.info(u"Marking productOnClient %s for deletion, client doesn't exists" % productOnClient)
			deleteProductOnClients.append(productOnClient)
		elif productOnClient.installationStatus == 'not_installed' and productOnClient.actionRequest == 'none':
			logger.info(u"Marking productOnClient %s for deletion" % productOnClient)
			deleteProductOnClients.append(productOnClient)
		
	if deleteProductOnClients:
		backend.productOnClient_deleteObjects(deleteProductOnClients)
	
	deleteProductOnClients = []
	productIds = []
	for product in backend.product_getObjects():
		if not product.getId() in productIds:
			productIds.append(product.getId())
	for productOnClient in backend.productOnClient_getObjects():
		if not productOnClient.productId in productIds:
			logger.info(u"Marking productOnClient %s for deletion" % productOnClient)
			deleteProductOnClients.append(productOnClient)
	if deleteProductOnClients:
		backend.productOnClient_deleteObjects(deleteProductOnClients)
	
	logger.notice(u"Cleaning up product properties")
	productPropertyIdents = []
	deleteProductProperties = []
	productPropertiesToCleanup = {}
	for productProperty in backend.productProperty_getObjects():
		productIdent = u"%s;%s;%s" % (productProperty.productId, productProperty.productVersion, productProperty.packageVersion)
		if not productProperty.editable and productProperty.possibleValues:
			productPropertyIdent = u"%s;%s" % (productIdent, productProperty.propertyId)
			productPropertiesToCleanup[productPropertyIdent] = productProperty
		if not productIdent in productIdents:
			logger.info(u"Marking productProperty %s of non existent product '%s' for deletion" % (productProperty, productIdent))
			deleteProductProperties.append(productProperty)
		else:
			productPropertyIdent = u'%s;%s' % (productProperty.productId, productProperty.propertyId)
			if not productPropertyIdent in productPropertyIdents:
				productPropertyIdents.append(productPropertyIdent)
	if deleteProductProperties:
		backend.productProperty_deleteObjects(deleteProductProperties)
	
	logger.notice(u"Cleaning up product property states")
	deleteProductPropertyStates = []
	for productPropertyState in backend.productPropertyState_getObjects():
		productPropertyIdent = u'%s;%s' % (productPropertyState.productId, productPropertyState.propertyId)
		if not productPropertyIdent in productPropertyIdents:
			logger.info(u"Marking productPropertyState %s of non existent productProperty '%s' for deletion" % (productPropertyState, productPropertyIdent))
			deleteProductPropertyStates.append(productPropertyState)
	if deleteProductPropertyStates:
		backend.productPropertyState_deleteObjects(deleteProductPropertyStates)
	
	for depot in backend.host_getObjects(type = 'OpsiDepotserver'):
		objectIds = [ depot.id ]
		for clientToDepot in backend.configState_getClientToDepotserver(depotIds = depot.id):
			if not clientToDepot['clientId'] in objectIds:
				objectIds.append(clientToDepot['clientId'])
		productOnDepotIdents = {}
		for productOnDepot in backend.productOnDepot_getObjects(depotId = depot.id):
			productIdent = u"%s;%s;%s" % (productOnDepot.productId, productOnDepot.productVersion, productOnDepot.packageVersion)
			productOnDepotIdents[productOnDepot.productId] = productIdent
		if not productOnDepotIdents:
			continue
		deleteProductPropertyStates = []
		updateProductPropertyStates = []
		for productPropertyState in backend.productPropertyState_getObjects(
						objectId   = objectIds,
						productId  = productOnDepotIdents.keys(),
						propertyId = []):
			productIdent = productOnDepotIdents.get(productPropertyState.productId)
			if not productIdent:
				continue
			productPropertyIdent = u"%s;%s" % (productIdent, productPropertyState.propertyId)
			productProperty = productPropertiesToCleanup.get(productPropertyIdent)
			if not productProperty:
				continue
			changed = False
			newValues = []
			removeValues = []
			changedValues = []
			for v in productPropertyState.values:
				if v in productProperty.possibleValues:
					newValues.append(v)
					continue
				if (productProperty.getType() == 'BoolProductProperty') and forceBool(v) in productProperty.possibleValues:
					newValues.append(forceBool(v))
					changedValues.append(v)
					changed = True
					continue
				if (productProperty.getType() == 'UnicodeProductProperty'):
					newValue = None
					for pv in productProperty.possibleValues:
						if (forceUnicodeLower(pv) == forceUnicodeLower(v)):
							newValue = pv
							break
					if newValue:
						newValues.append(newValue)
						changedValues.append(v)
						changed = True
						continue
				removeValues.append(v)
				changed = True
			if changed:
				if not newValues:
					logger.info(u"Marking productPropertyState %s for deletion: no value in possible values (%s)" % (productPropertyState, removeValues))
					deleteProductPropertyStates.append(productPropertyState)
				else:
					productPropertyState.setValues(newValues)
					logger.info(u"Marking productPropertyState %s for update: values not in possible values: %s, values corrected: %s" % (productPropertyState, removeValues, changedValues))
					updateProductPropertyStates.append(productPropertyState)
		if deleteProductPropertyStates:
			backend.productPropertyState_deleteObjects(deleteProductPropertyStates)
		if updateProductPropertyStates:
			backend.productPropertyState_updateObjects(updateProductPropertyStates)
	
	logger.notice(u"Cleaning up config states")
	deleteConfigStates = []
	configIds = backend.config_getIdents()
	for configState in backend.configState_getObjects():
		if not configState.configId in configIds:
			logger.info(u"Marking configState %s of non existent config '%s' for deletion" % (configState, configState.configId))
			deleteConfigStates.append(configState)
	if deleteConfigStates:
		backend.configState_deleteObjects(deleteConfigStates)
	
	logger.notice(u"Cleaning up audit softwares")
	idents = []
	for aso in backend.auditSoftwareOnClient_getHashes():
		ident = '%(name)s;%(version)s;%(subVersion)s;%(language)s;%(architecture)s' % aso
		if not ident in idents:
			idents.append(ident)
	
	for aso in backend.auditSoftware_getHashes():
		ident = '%(name)s;%(version)s;%(subVersion)s;%(language)s;%(architecture)s' % aso
		if not ident in idents:
			logger.info(u"Deleting unreferenced audit software '%s'" % ident)
			backend.auditSoftware_delete(aso['name'], aso['version'], aso['subVersion'], aso['language'], aso['architecture'])
	
	logger.notice(u"Cleaning up audit software on clients")
	idents = []
	for aso in backend.auditSoftware_getHashes():
		ident = '%(name)s;%(version)s;%(subVersion)s;%(language)s;%(architecture)s' % aso
		if not ident in idents:
			idents.append(ident)
	
	for aso in backend.auditSoftwareOnClient_getHashes():
		ident = '%(name)s;%(version)s;%(subVersion)s;%(language)s;%(architecture)s' % aso
		if not ident in idents:
			logger.info(u"Deleting audit software on client '%s'" % ident)
			backend.auditSoftwareOnClient_delete(aso['name'], aso['version'], aso['subVersion'], aso['language'], aso['architecture'], aso['clientId'])
	
	
	
	
def usage():
	print u"\nUsage: %s [options]" % os.path.basename(sys.argv[0])
	print u""
	print u"Options:"
	print u"   -h, --help  show this help"
	print u"   -l          log-level 0..9"
	print u""
	print u"   --log-file <path>             path to log file"
	print u"   --backend-config <json hash>  overwrite backend config hash values"
	print u"   --ip-address <ip>             force to this ip address (do not lookup by name)"
	print u"   --register-depot              register depot at config server"
	print u"   --set-rights [path]           set default rights on opsi files (in [path] only)"
	print u"   --init-current-config         init current backend configuration"
	print u"   --update-from=<version>       update from opsi version <version>"
	print u"   --update-mysql                update mysql backend"
	print u"   --update-ldap                 update ldap backend"
	print u"   --update-univention           update univention backend"
	print u"   --update-file                 update file backend"
	print u"   --configure-mysql             configure mysql backend"
	print u"   --edit-config-defaults        edit global config defaults"
	print u"   --cleanup-backend             cleanup backend"
	print u"   --auto-configure-samba        patch smb.conf"
	print u"   --auto-configure-dhcpd        patch dhcpd.conf"
	print u"   --renew-opsiconfd-cert        renew opsiconfd-cert"
	print u""
	
def main():
	if (os.geteuid() != 0):
		raise Exception(u"This script must be startet as root")
	
	try:
		(opts, args) = getopt.getopt(sys.argv[1:], "hl:",
			['help', 'log-file=', 'ip-address=', 'backend-config=', 'init-current-config', 'set-rights', 'auto-configure-samba', 'auto-configure-dhcpd',
			 'register-depot', 'configure-mysql', 'update-mysql', 'update-ldap', 'update-univention', 'update-file', 'edit-config-defaults', 'cleanup-backend',
			 'update-from=', 'binddata=', 'renew-opsiconfd-cert'])
		
	except Exception, e:
		usage()
		raise
	
	task = None
	updateFrom = None
	autoConfigureSamba = False
	autoConfigureDhcpd = False
	global ipAddress
	ipAddress = None
	global backendConfig
	backendConfig = {}
	username = None
	password = None
	configserver = None
	
	
	for (opt, arg) in opts:
		if opt in ("-h", "--help"):
			usage()
			return
		elif (opt == "--log-file"):
			logger.setLogFile(arg)
			logger.setFileLevel(LOG_DEBUG)
		elif (opt == "-l"):
			logger.setConsoleLevel(int(arg))
		elif (opt == "--ip-address"):
			ipAddress = forceIpAddress(arg)
		elif (opt == "--backend-config"):
			backendConfig = json.loads(arg)
		elif (opt == "--init-current-config"):
			task = 'init-current-config'
		elif (opt == "--set-rights"):
			task = 'set-rights'
		elif (opt == "--register-depot"):
			task = 'register-depot'
		elif (opt == "--configure-mysql"):
			task = 'configure-mysql'
		elif (opt == "--update-mysql"):
			task = 'update-mysql'
		elif (opt == "--update-ldap"):
			task = 'update-ldap'
		elif (opt == "--update-univention"):
			task = 'update-univention'
		elif (opt == "--update-file"):
			task = 'update-file'
		elif (opt == "--edit-config-defaults"):
			task = 'edit-config-defaults'
		elif (opt == "--cleanup-backend"):
			task = 'cleanup-backend'
		elif (opt == "--update-from"):
			updateFrom = arg
		elif (opt == "--auto-configure-samba"):
			autoConfigureSamba = True
		elif (opt == "--auto-configure-dhcpd"):
			autoConfigureDhcpd = True
		elif (opt == "--renew-opsiconfd-cert"):
			task = "renew-opsiconfd-cert"
		elif (opt == "--binddata"):
			# Not documented option for automatic use from register-depot task in univention-join-script
			i = 0
			arglist = arg.split(" ")
			for entry in arglist:
				if "configserver" in entry:
					configserver = arglist[i + 1]
				elif "binddn" in entry:
					temp = arglist[i + 1]
					if "=" in temp:
						username = temp.split("=")[1].split(",")[0]
				elif "bindpw" in entry:
					password = arglist[i + 1]
				if i >= len(arglist) - 2:
					break
				else:
					i += 1
	
	path = u'/'
	if (len(args) > 0):
		if (task == 'set-rights') and (len(args) == 1):
			path = os.path.abspath(forceFilename(args[0]))
		elif (task == 'register-depot'):
			pass
		else:
			usage()
			raise Exception(u"Too many arguments")
	
	if autoConfigureSamba:
		configureSamba()
	
	if autoConfigureDhcpd:
		configureDHCPD()
	
	if   (task == 'set-rights'):
		setRights(path)
	
	elif (task == 'init-current-config'):
		initializeBackends()
		configureClientUser()
	
	elif (task == 'configure-mysql'):
		configureMySQLBackend()
	
	elif (task == 'update-mysql'):
		updateMySQLBackend()
		update()
	
	elif (task == 'update-ldap'):
		updateLDAPBackend()
		update()
	
	elif (task == 'update-univention'):
		updateUniventionBackend()
		update()
	
	elif (task == 'update-file'):
		updateFileBackend()
		update()
	
	elif (task == 'register-depot'):
		registerDepot(username, password, configserver)
		configureClientUser()
		
	elif (task == 'edit-config-defaults'):
		editConfigDefaults()
	
	elif (task == 'cleanup-backend'):
		cleanupBackend()
		
	elif (task == "renew-opsiconfd-cert"):
		renewOpsiconfdCert()
	
	elif (updateFrom):
		update(updateFrom)
	
	elif not autoConfigureSamba and not autoConfigureDhcpd:
		usage()
		sys.exit(1)
	
if (__name__ == "__main__"):
	logger.setLogFormat(u'[%l] [%D] %M (%F|%N)')
	logger.setLogFile(LOG_FILE)
	logger.setFileLevel(LOG_INFO)
	exception = None
	try:
		main()
	except SystemExit, e:
		pass
	
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, u"\nERROR: %s\n" % exception
		sys.exit(1)
	sys.exit(0)















